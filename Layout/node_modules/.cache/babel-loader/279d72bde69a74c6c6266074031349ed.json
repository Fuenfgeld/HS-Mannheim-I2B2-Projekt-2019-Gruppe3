{"ast":null,"code":"import CanvasJSObject from './canvasjs';\nimport TextBlock from './text_block';\nimport { extend, numberFormat, getLineDashArray } from '../helpers/utils';\n\nfunction Axis(chart, options, type, position) {\n  Axis.base.constructor.call(this, \"Axis\", options, chart.theme);\n  this.chart = chart;\n  this.canvas = chart.canvas;\n  this.ctx = chart.ctx;\n  this.maxWidth = 0;\n  this.maxHeight = 0;\n  this.intervalStartPosition = 0;\n  this.labels = [];\n  this._labels = null; //Processed information about the data that gets plotted against this axis\n\n  this.dataInfo = {\n    min: Infinity,\n    max: -Infinity,\n    viewPortMin: Infinity,\n    viewPortMax: -Infinity,\n    minDiff: Infinity // Used only in case of axisX\n\n  };\n\n  if (type === \"axisX\") {\n    this.sessionVariables = this.chart.sessionVariables[type];\n    if (!this._options.interval) this.intervalType = null;\n  } else {\n    if (position === \"left\" || position === \"top\") this.sessionVariables = this.chart.sessionVariables[\"axisY\"];else {\n      this.sessionVariables = this.chart.sessionVariables[\"axisY2\"];\n    }\n  }\n\n  if (typeof this._options.titleFontSize === \"undefined\") {\n    this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize); //window.console.log(\"titleFontSize: \" + this.titleFontSize);\n  }\n\n  if (typeof this._options.labelFontSize === \"undefined\") {\n    this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize); //window.console.log(\"labelFontSize: \" + this.labelFontSize);\n  } //Axis Type : axisX, axisY\n\n\n  this.type = type;\n  if (type === \"axisX\" && (!options || typeof options.gridThickness === \"undefined\")) this.gridThickness = 0;\n  this._position = position;\n  this.lineCoordinates = {\n    x1: null,\n    y1: null,\n    x2: null,\n    y2: null,\n    width: null\n  }; //{x1:, y1:, x2:, y2:, width:}\n  //\n\n  {\n    this.labelAngle = (this.labelAngle % 360 + 360) % 360;\n    if (this.labelAngle > 90 && this.labelAngle <= 270) this.labelAngle -= 180;else if (this.labelAngle > 180 && this.labelAngle <= 270) this.labelAngle -= 180;else if (this.labelAngle > 270 && this.labelAngle <= 360) this.labelAngle -= 360;\n  }\n\n  if (this._options.stripLines && this._options.stripLines.length > 0) {\n    this.stripLines = [];\n\n    for (var i = 0; i < this._options.stripLines.length; i++) {\n      this.stripLines.push(new StripLine(this.chart, this._options.stripLines[i], chart.theme, ++this.chart._eventManager.lastObjectId, this));\n    }\n  }\n\n  this._titleTextBlock = null;\n  if (!this.hasOptionChanged(\"viewportMinimum\") && !isNaN(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum !== null) this.viewportMinimum = this.sessionVariables.newViewportMinimum;else this.sessionVariables.newViewportMinimum = null;\n  if (!this.hasOptionChanged(\"viewportMaximum\") && !isNaN(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum !== null) this.viewportMaximum = this.sessionVariables.newViewportMaximum;else this.sessionVariables.newViewportMaximum = null;\n  if (this.minimum !== null && this.viewportMinimum !== null) this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);\n  if (this.maximum !== null && this.viewportMaximum !== null) this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);\n  this.trackChanges(\"viewportMinimum\");\n  this.trackChanges(\"viewportMaximum\");\n}\n\nextend(Axis, CanvasJSObject);\n\nAxis.prototype.createLabels = function () {\n  var textBlock;\n  var i = 0;\n  var endPoint;\n  var labelMaxWidth = 0;\n  var labelMaxHeight = 0;\n  var intervalInPixels = 0; //var intervalInPixels = this.conversionParameters.pixelPerUnit * this.interval;\n\n  if (this._position === \"bottom\" || this._position === \"top\") {\n    intervalInPixels = this.lineCoordinates.width / Math.abs(this.viewportMaximum - this.viewportMinimum) * this.interval;\n\n    if (this.labelAutoFit) {\n      labelMaxWidth = typeof this._options.labelMaxWidth === \"undefined\" ? intervalInPixels * .9 >> 0 : this.labelMaxWidth;\n    } else {\n      labelMaxWidth = typeof this._options.labelMaxWidth === \"undefined\" ? this.chart.width * .7 >> 0 : this.labelMaxWidth;\n    }\n\n    labelMaxHeight = typeof this._options.labelWrap === \"undefined\" || this.labelWrap ? this.chart.height * .5 >> 0 : this.labelFontSize * 1.5;\n  } else if (this._position === \"left\" || this._position === \"right\") {\n    intervalInPixels = this.lineCoordinates.height / Math.abs(this.viewportMaximum - this.viewportMinimum) * this.interval;\n\n    if (this.labelAutoFit) {\n      labelMaxWidth = typeof this._options.labelMaxWidth === \"undefined\" ? this.chart.width * .3 >> 0 : this.labelMaxWidth;\n    } else {\n      labelMaxWidth = typeof this._options.labelMaxWidth === \"undefined\" ? this.chart.width * .5 >> 0 : this.labelMaxWidth;\n    }\n\n    labelMaxHeight = typeof this._options.labelWrap === \"undefined\" || this.labelWrap ? intervalInPixels * 2 >> 0 : this.labelFontSize * 1.5;\n  }\n\n  if (this.type === \"axisX\" && this.chart.plotInfo.axisXValueType === \"dateTime\") {\n    endPoint = addToDateTime(new Date(this.viewportMaximum), this.interval, this.intervalType); //endPoint = this.viewportMaximum;\n\n    for (i = this.intervalStartPosition; i < endPoint; addToDateTime(i, this.interval, this.intervalType)) {\n      //var text = dateFormat(i, this.valueFormatString);\n      var timeInMilliseconds = i.getTime();\n      var text = this.labelFormatter ? this.labelFormatter({\n        chart: this.chart,\n        axis: this._options,\n        value: i,\n        label: this.labels[i] ? this.labels[i] : null\n      }) : this.type === \"axisX\" && this.labels[timeInMilliseconds] ? this.labels[timeInMilliseconds] : dateFormat(i, this.valueFormatString, this.chart._cultureInfo);\n      textBlock = new TextBlock(this.ctx, {\n        x: 0,\n        y: 0,\n        //maxWidth: this.maxHeight,\n        //maxHeight: this.labelFontSize,\n        maxWidth: labelMaxWidth,\n        maxHeight: labelMaxHeight,\n        angle: this.labelAngle,\n        text: this.prefix + text + this.suffix,\n        horizontalAlign: \"left\",\n        //left, center, right\n        fontSize: this.labelFontSize,\n        //in pixels\n        fontFamily: this.labelFontFamily,\n        fontWeight: this.labelFontWeight,\n        //normal, bold, bolder, lighter,\n        fontColor: this.labelFontColor,\n        fontStyle: this.labelFontStyle,\n        // normal, italic, oblique\n        textBaseline: \"middle\"\n      });\n\n      this._labels.push({\n        position: i.getTime(),\n        textBlock: textBlock,\n        effectiveHeight: null\n      });\n    }\n  } else {\n    endPoint = this.viewportMaximum; //if ((Math.floor(this.interval) < this.interval && !this._options.interval) || true) {\n    //Check if it should be rendered as a category axis. If yes, then ceil the interval\n\n    if (this.labels && this.labels.length) {\n      var tempInterval = Math.ceil(this.interval);\n      var tempStartPoint = Math.ceil(this.intervalStartPosition);\n      var hasAllLabels = false;\n\n      for (i = tempStartPoint; i < this.viewportMaximum; i += tempInterval) {\n        if (this.labels[i]) {\n          hasAllLabels = true;\n        } else {\n          hasAllLabels = false;\n          break;\n        }\n      }\n\n      if (hasAllLabels) {\n        this.interval = tempInterval;\n        this.intervalStartPosition = tempStartPoint;\n      }\n    } //parseFloat & toPrecision are being used to avoid issues related to precision.\n\n\n    for (i = this.intervalStartPosition; i <= endPoint; i = parseFloat((i + this.interval).toFixed(14))) {\n      var text = this.labelFormatter ? this.labelFormatter({\n        chart: this.chart,\n        axis: this._options,\n        value: i,\n        label: this.labels[i] ? this.labels[i] : null\n      }) : this.type === \"axisX\" && this.labels[i] ? this.labels[i] : numberFormat(i, this.valueFormatString, this.chart._cultureInfo);\n      textBlock = new TextBlock(this.ctx, {\n        x: 0,\n        y: 0,\n        //maxWidth: this.maxHeight,\n        //maxHeight: this.labelFontSize,\n        maxWidth: labelMaxWidth,\n        maxHeight: labelMaxHeight,\n        angle: this.labelAngle,\n        text: this.prefix + text + this.suffix,\n        horizontalAlign: \"left\",\n        //left, center, right\n        fontSize: this.labelFontSize,\n        //in pixels\n        fontFamily: this.labelFontFamily,\n        fontWeight: this.labelFontWeight,\n        //normal, bold, bolder, lighter,\n        fontColor: this.labelFontColor,\n        fontStyle: this.labelFontStyle,\n        // normal, italic, oblique\n        textBaseline: \"middle\",\n        borderThickness: 0\n      });\n\n      this._labels.push({\n        position: i,\n        textBlock: textBlock,\n        effectiveHeight: null\n      });\n    }\n  }\n\n  for (var i = 0; i < this.stripLines.length; i++) {\n    var stripLine = this.stripLines[i];\n    textBlock = new TextBlock(this.ctx, {\n      x: 0,\n      y: 0,\n      //maxWidth: this.maxHeight,\n      //maxHeight: this.labelFontSize,\n      backgroundColor: stripLine.labelBackgroundColor,\n      maxWidth: labelMaxWidth,\n      maxHeight: labelMaxHeight,\n      angle: this.labelAngle,\n      text: stripLine.labelFormatter ? stripLine.labelFormatter({\n        chart: this.chart,\n        axis: this,\n        stripLine: stripLine\n      }) : stripLine.label,\n      horizontalAlign: \"left\",\n      //left, center, right\n      fontSize: stripLine.labelFontSize,\n      //in pixels\n      fontFamily: stripLine.labelFontFamily,\n      fontWeight: stripLine.labelFontWeight,\n      //normal, bold, bolder, lighter,\n      fontColor: stripLine._options.labelFontColor || stripLine.color,\n      fontStyle: stripLine.labelFontStyle,\n      // normal, italic, oblique\n      textBaseline: \"middle\",\n      borderThickness: 0\n    });\n\n    this._labels.push({\n      position: stripLine.value,\n      textBlock: textBlock,\n      effectiveHeight: null,\n      stripLine: stripLine\n    });\n  }\n};\n\nAxis.prototype.createLabelsAndCalculateWidth = function () {\n  var maxLabelEffectiveWidth = 0;\n  this._labels = [];\n\n  if (this._position === \"left\" || this._position === \"right\") {\n    this.createLabels();\n\n    for (var i = 0; i < this._labels.length; i++) {\n      var textBlock = this._labels[i].textBlock;\n      var size = textBlock.measureText(); //var hypotenuse = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width, 2));\n      //labelEffectiveWidth = hypotenuse * Math.cos(Math.abs(Math.PI / 180 * this.labelAngle) - Math.abs(Math.acos(size.width / hypotenuse)));\n\n      var labelEffectiveWidth = 0;\n      if (this.labelAngle === 0) labelEffectiveWidth = size.width;else labelEffectiveWidth = size.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + size.height / 2 * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\n      if (maxLabelEffectiveWidth < labelEffectiveWidth) maxLabelEffectiveWidth = labelEffectiveWidth;\n      this._labels[i].effectiveWidth = labelEffectiveWidth;\n    }\n  }\n\n  var titleHeight = this.title ? getFontHeightInPixels(this.titleFontFamily, this.titleFontSize, this.titleFontWeight) + 2 : 0;\n  var axisWidth = titleHeight + maxLabelEffectiveWidth + this.tickLength + 5; //if (isDebugMode && window.console) {\n  //\twindow.console.log(this.type + \"--- axisWidth: \" + axisWidth);\n  //}\n\n  return axisWidth;\n};\n\nAxis.prototype.createLabelsAndCalculateHeight = function () {\n  var maxLabelEffectiveHeight = 0;\n  this._labels = [];\n  var textBlock;\n  var i = 0;\n  this.createLabels();\n\n  if (this._position === \"bottom\" || this._position === \"top\") {\n    for (i = 0; i < this._labels.length; i++) {\n      textBlock = this._labels[i].textBlock;\n      var size = textBlock.measureText(); //var diagonal = Math.sqrt(Math.pow(size.height, 2) + Math.pow(size.width, 2));\n      //var hypotenuse = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width, 2));\n      //var labelEffectiveHeight = hypotenuse * Math.cos(Math.PI / 2 - (Math.abs(Math.PI / 180 * this.labelAngle) + Math.abs(Math.acos(size.width / hypotenuse))));\n\n      var labelEffectiveHeight = 0;\n      if (this.labelAngle === 0) labelEffectiveHeight = size.height;else labelEffectiveHeight = size.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + size.height / 2 * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\n      if (maxLabelEffectiveHeight < labelEffectiveHeight) maxLabelEffectiveHeight = labelEffectiveHeight;\n      this._labels[i].effectiveHeight = labelEffectiveHeight;\n    }\n  } //var titleHeight = this.title ? this.titleFontSize + 5 : 0;\n\n\n  var titleHeight = this.title ? getFontHeightInPixels(this.titleFontFamily, this.titleFontSize, this.titleFontWeight) + 2 : 0;\n  return titleHeight + maxLabelEffectiveHeight + this.tickLength + 5;\n}; //Static Method that co-ordinates between axisX, axisY and renders them\n\n\nAxis.setLayoutAndRender = function (axisX, axisY, axisY2, axisPlacement, freeSpace) {\n  var x1, y1, x2, y2;\n  var chart = axisX.chart;\n  var ctx = chart.ctx;\n  axisX.calculateAxisParameters();\n  if (axisY) axisY.calculateAxisParameters();\n  if (axisY2) axisY2.calculateAxisParameters(); //if (axisY && axisY2 && typeof (axisY._options.viewportMaximum) === \"undefined\" && typeof (axisY._options.viewportMinimum) === \"undefined\" && typeof (axisY._options.interval) === \"undefined\"\n  //\t\t&& typeof (axisY2._options.viewportMaximum) === \"undefined\" && typeof (axisY2._options.viewportMinimum) === \"undefined\" && typeof (axisY2._options.interval) === \"undefined\") {\n  //\tvar noTicksY = (axisY.viewportMaximum - axisY.viewportMinimum) / axisY.interval;\n  //\tvar noTicksY2 = (axisY2.viewportMaximum - axisY2.viewportMinimum) / axisY2.interval;\n  //\tif (noTicksY > noTicksY2) {\n  //\t\taxisY2.viewportMaximum = axisY2.interval * noTicksY + axisY2.viewportMinimum;\n  //\t} else if (noTicksY2 > noTicksY) {\n  //\t\taxisY.viewportMaximum = axisY.interval * noTicksY2 + axisY.viewportMinimum;\n  //\t}\n  //}\n\n  var axisYlineThickness = axisY ? axisY.lineThickness ? axisY.lineThickness : 0 : 0;\n  var axisY2lineThickness = axisY2 ? axisY2.lineThickness ? axisY2.lineThickness : 0 : 0;\n  var axisYGridThickness = axisY ? axisY.gridThickness ? axisY.gridThickness : 0 : 0;\n  var axisY2GridThickness = axisY2 ? axisY2.gridThickness ? axisY2.gridThickness : 0 : 0;\n  var axisYMargin = axisY ? axisY.margin : 0;\n  var axisY2Margin = axisY ? axisY.margin : 0;\n\n  if (axisPlacement === \"normal\") {\n    axisX.lineCoordinates = {};\n    var axisYWidth = Math.ceil(axisY ? axisY.createLabelsAndCalculateWidth() : 0);\n    x1 = Math.round(freeSpace.x1 + axisYWidth + axisYMargin);\n    axisX.lineCoordinates.x1 = x1;\n    var axisY2Width = Math.ceil(axisY2 ? axisY2.createLabelsAndCalculateWidth() : 0);\n    x2 = Math.round(freeSpace.x2 - axisY2Width > axisX.chart.width - 10 ? axisX.chart.width - 10 : freeSpace.x2 - axisY2Width);\n    axisX.lineCoordinates.x2 = x2;\n    axisX.lineCoordinates.width = Math.abs(x2 - x1); // required early on inside createLabels of axisX\n\n    var axisXHeight = Math.ceil(axisX.createLabelsAndCalculateHeight()); // Position axisX based on the available free space, Margin and its height\n    //x1 = freeSpace.x1 + axisYWidth + axisYMargin + axisYlineThickness / 2;\n\n    y1 = Math.round(freeSpace.y2 - axisXHeight - axisX.margin);\n    y2 = Math.round(freeSpace.y2 - axisX.margin); //axisX.lineCoordinates = { x1: x1, y1: y1, x2: x2, y2: y1, width: Math.abs(x2 - x1) }\n\n    axisX.lineCoordinates.y1 = y1;\n    axisX.lineCoordinates.y2 = y1;\n    axisX.boundingRect = {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      width: x2 - x1,\n      height: y2 - y1\n    }; //if (isDebugMode) {\n    //\taxisX.ctx.rect(axisX.boundingRect.x1, axisX.boundingRect.y1, axisX.boundingRect.width, axisX.boundingRect.height);\n    //\taxisX.ctx.stroke();\n    //}\n    // Position axisY based on the available free space, Margin and its height\n\n    if (axisY) {\n      x1 = Math.round(freeSpace.x1 + axisY.margin);\n      y1 = Math.round(freeSpace.y1 < 10 ? 10 : freeSpace.y1);\n      x2 = Math.round(freeSpace.x1 + axisYWidth + axisY.margin); //y2 = freeSpace.y2 - axisXHeight - axisX.margin - axisX.lineThickness / 2;\n\n      y2 = Math.round(freeSpace.y2 - axisXHeight - axisX.margin);\n      axisY.lineCoordinates = {\n        x1: x2,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        height: Math.abs(y2 - y1)\n      };\n      axisY.boundingRect = {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        width: x2 - x1,\n        height: y2 - y1\n      };\n    } //if (isDebugMode && axisY) {\n    //\taxisY.ctx.rect(axisY.boundingRect.x1, axisY.boundingRect.y1, axisY.boundingRect.width, axisY.boundingRect.height);\n    //\taxisY.ctx.stroke();\n    //}\n    // Position axisY2 based on the available free space, Margin and its height\n\n\n    if (axisY2) {\n      x1 = Math.round(axisX.lineCoordinates.x2);\n      y1 = Math.round(freeSpace.y1 < 10 ? 10 : freeSpace.y1);\n      x2 = Math.round(x1 + axisY2Width + axisY2.margin); //y2 = freeSpace.y2 - axisXHeight - axisX.margin - axisX.lineThickness / 2;\n\n      y2 = Math.round(freeSpace.y2 - axisXHeight - axisX.margin);\n      axisY2.lineCoordinates = {\n        x1: x1,\n        y1: y1,\n        x2: x1,\n        y2: y2,\n        height: Math.abs(y2 - y1)\n      };\n      axisY2.boundingRect = {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        width: x2 - x1,\n        height: y2 - y1\n      };\n    }\n\n    axisX.calculateValueToPixelConversionParameters();\n    if (axisY) axisY.calculateValueToPixelConversionParameters();\n    if (axisY2) axisY2.calculateValueToPixelConversionParameters();\n    ctx.save();\n    ctx.rect(5, axisX.boundingRect.y1, axisX.chart.width - 10, axisX.boundingRect.height);\n    ctx.clip();\n    axisX.renderLabelsTicksAndTitle();\n    ctx.restore();\n    if (axisY) axisY.renderLabelsTicksAndTitle();\n    if (axisY2) axisY2.renderLabelsTicksAndTitle();\n    chart.preparePlotArea();\n    var plotArea = axisX.chart.plotArea;\n    ctx.save();\n    ctx.rect(plotArea.x1, plotArea.y1, Math.abs(plotArea.x2 - plotArea.x1), Math.abs(plotArea.y2 - plotArea.y1));\n    ctx.clip();\n    axisX.renderStripLinesOfThicknessType(\"value\");\n    if (axisY) axisY.renderStripLinesOfThicknessType(\"value\");\n    if (axisY2) axisY2.renderStripLinesOfThicknessType(\"value\");\n    axisX.renderInterlacedColors();\n    if (axisY) axisY.renderInterlacedColors();\n    if (axisY2) axisY2.renderInterlacedColors();\n    ctx.restore();\n    axisX.renderGrid();\n    if (axisY) axisY.renderGrid();\n    if (axisY2) axisY2.renderGrid();\n    axisX.renderAxisLine();\n    if (axisY) axisY.renderAxisLine();\n    if (axisY2) axisY2.renderAxisLine(); //No need to clip to plotArea because stripLines need to render on top of gridlines\n\n    axisX.renderStripLinesOfThicknessType(\"pixel\");\n    if (axisY) axisY.renderStripLinesOfThicknessType(\"pixel\");\n    if (axisY2) axisY2.renderStripLinesOfThicknessType(\"pixel\");\n  } else {\n    var axisXWidth = Math.ceil(axisX.createLabelsAndCalculateWidth());\n\n    if (axisY) {\n      axisY.lineCoordinates = {};\n      x1 = Math.round(freeSpace.x1 + axisXWidth + axisX.margin);\n      x2 = Math.round(freeSpace.x2 > axisY.chart.width - 10 ? axisY.chart.width - 10 : freeSpace.x2);\n      axisY.lineCoordinates.x1 = x1;\n      axisY.lineCoordinates.x2 = x2;\n      axisY.lineCoordinates.width = Math.abs(x2 - x1);\n    }\n\n    if (axisY2) {\n      axisY2.lineCoordinates = {};\n      x1 = Math.round(freeSpace.x1 + axisXWidth + axisX.margin);\n      x2 = Math.round(freeSpace.x2 > axisY2.chart.width - 10 ? axisY2.chart.width - 10 : freeSpace.x2);\n      axisY2.lineCoordinates.x1 = x1;\n      axisY2.lineCoordinates.x2 = x2;\n      axisY2.lineCoordinates.width = Math.abs(x2 - x1);\n    }\n\n    var axisYHeight = Math.ceil(axisY ? axisY.createLabelsAndCalculateHeight() : 0);\n    var axisY2Height = Math.ceil(axisY2 ? axisY2.createLabelsAndCalculateHeight() : 0); // Position axisY based on the available free space, Margin and its height\n\n    if (axisY) {\n      //x1 = freeSpace.x1 + axisXWidth + axisX.margin + axisX.lineThickness / 2;\n      //x2 = freeSpace.x2 > axisY.chart.width - 10 ? axisY.chart.width - 10 : freeSpace.x2;\n      y1 = Math.round(freeSpace.y2 - axisYHeight - axisY.margin);\n      y2 = Math.round(freeSpace.y2 - axisYMargin > axisY.chart.height - 10 ? axisY.chart.height - 10 : freeSpace.y2 - axisYMargin); //axisY.lineCoordinates = { x1: x1, y1: y1, x2: x2, y2: y1, width: Math.abs(x2 - x1) }\n\n      axisY.lineCoordinates.y1 = y1;\n      axisY.lineCoordinates.y2 = y1;\n      axisY.boundingRect = {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        width: x2 - x1,\n        height: axisYHeight\n      };\n    } // Position axisY based on the available free space, Margin and its height\n\n\n    if (axisY2) {\n      //x1 = freeSpace.x1 + axisXWidth + axisX.margin + axisX.lineThickness / 2;\n      //x2 = freeSpace.x2 > axisY2.chart.width - 10 ? axisY2.chart.width - 10 : freeSpace.x2;\n      y1 = Math.round(freeSpace.y1 + axisY2.margin);\n      y2 = freeSpace.y1 + axisY2.margin + axisY2Height; //axisY2.lineCoordinates = { x1: x1, y1: y2, x2: x2, y2: y2, width: Math.abs(x2 - x1) }\n\n      axisY2.lineCoordinates.y1 = y2;\n      axisY2.lineCoordinates.y2 = y2;\n      axisY2.boundingRect = {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        width: x2 - x1,\n        height: axisY2Height\n      };\n    } //axisY.ctx.rect(axisY.boundingRect.x1, axisY.boundingRect.y1, axisY.boundingRect.width, axisY.boundingRect.height);\n    //axisY.ctx.stroke();\n    // Position axisX based on the available free space, Margin and its height\n\n\n    x1 = Math.round(freeSpace.x1 + axisX.margin);\n    y1 = Math.round(axisY2 ? axisY2.lineCoordinates.y2 : freeSpace.y1 < 10 ? 10 : freeSpace.y1);\n    x2 = Math.round(freeSpace.x1 + axisXWidth + axisX.margin);\n    y2 = Math.round(axisY ? axisY.lineCoordinates.y1 : freeSpace.y2 - axisYMargin > axisX.chart.height - 10 ? axisX.chart.height - 10 : freeSpace.y2 - axisYMargin);\n    axisX.lineCoordinates = {\n      x1: x2,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      height: Math.abs(y2 - y1)\n    };\n    axisX.boundingRect = {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      width: x2 - x1,\n      height: y2 - y1\n    }; //axisX.ctx.rect(axisX.boundingRect.x1, axisX.boundingRect.y1, axisX.boundingRect.width, axisX.boundingRect.height);\n    //axisX.ctx.stroke();\n\n    axisX.calculateValueToPixelConversionParameters();\n    if (axisY) axisY.calculateValueToPixelConversionParameters();\n    if (axisY2) axisY2.calculateValueToPixelConversionParameters(); //ctx.save();\n    //ctx.rect(axisY.boundingRect.x1 - 30, axisY.boundingRect.y1, axisY.boundingRect.width + 60, axisY.boundingRect.height);\n    //ctx.clip();\n\n    if (axisY) axisY.renderLabelsTicksAndTitle();\n    if (axisY2) axisY2.renderLabelsTicksAndTitle(); //ctx.restore();\n\n    axisX.renderLabelsTicksAndTitle();\n    chart.preparePlotArea();\n    var plotArea = axisX.chart.plotArea;\n    ctx.save();\n    ctx.rect(plotArea.x1, plotArea.y1, Math.abs(plotArea.x2 - plotArea.x1), Math.abs(plotArea.y2 - plotArea.y1));\n    ctx.clip(); //No need to clip to plotArea because stripLines need to render on top of gridlines\n\n    axisX.renderStripLinesOfThicknessType(\"value\");\n    if (axisY) axisY.renderStripLinesOfThicknessType(\"value\");\n    if (axisY2) axisY2.renderStripLinesOfThicknessType(\"value\");\n    axisX.renderInterlacedColors();\n    if (axisY) axisY.renderInterlacedColors();\n    if (axisY2) axisY2.renderInterlacedColors();\n    ctx.restore();\n    axisX.renderGrid();\n    if (axisY) axisY.renderGrid();\n    if (axisY2) axisY2.renderGrid();\n    axisX.renderAxisLine();\n    if (axisY) axisY.renderAxisLine();\n    if (axisY2) axisY2.renderAxisLine();\n    axisX.renderStripLinesOfThicknessType(\"pixel\");\n    if (axisY) axisY.renderStripLinesOfThicknessType(\"pixel\");\n    if (axisY2) axisY2.renderStripLinesOfThicknessType(\"pixel\");\n  }\n};\n\nAxis.prototype.renderLabelsTicksAndTitle = function () {\n  var skipLabels = false;\n  var totalLabelWidth = 0;\n  var thresholdRatio = 1;\n  var labelCount = 0;\n  var intervalInPixels = this.conversionParameters.pixelPerUnit * this.interval;\n  if (this.labelAngle !== 0 && this.labelAngle !== 360) thresholdRatio = 1.2; //Don't skip labels when interval is explicitely set\n\n  if (typeof this._options.interval === \"undefined\") {\n    if (this._position === \"bottom\" || this._position === \"top\") {\n      //thresholdRatio = .9;// More space is preferred between labels when axis is horizontally aligned\n      for (i = 0; i < this._labels.length; i++) {\n        label = this._labels[i];\n        if (label.position < this.viewportMinimum || label.stripLine) // don't consider stripLine's lable\n          continue;\n        var width = label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + label.textBlock.height * Math.sin(Math.PI / 180 * this.labelAngle);\n        totalLabelWidth += width;\n      }\n\n      if (totalLabelWidth > this.lineCoordinates.width * thresholdRatio) {\n        skipLabels = true;\n      }\n    }\n\n    if (this._position === \"left\" || this._position === \"right\") {\n      for (i = 0; i < this._labels.length; i++) {\n        label = this._labels[i];\n        if (label.position < this.viewportMinimum || label.stripLine) // don't consider stripLine's lable\n          continue;\n        var width = label.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle);\n        totalLabelWidth += width;\n      }\n\n      if (totalLabelWidth > this.lineCoordinates.height * thresholdRatio) {\n        skipLabels = true;\n      }\n    }\n  }\n\n  if (this._position === \"bottom\") {\n    var i = 0;\n    var label;\n    var xy;\n\n    for (i = 0; i < this._labels.length; i++) {\n      label = this._labels[i];\n      if (label.position < this.viewportMinimum || label.position > this.viewportMaximum) continue;\n      xy = this.getPixelCoordinatesOnAxis(label.position);\n\n      if (this.tickThickness && !this._labels[i].stripLine || this._labels[i].stripLine && this._labels[i].stripLine._thicknessType === \"pixel\") {\n        if (this._labels[i].stripLine) {\n          stripLine = this._labels[i].stripLine;\n          this.ctx.lineWidth = stripLine.thickness;\n          this.ctx.strokeStyle = stripLine.color;\n        } else {\n          this.ctx.lineWidth = this.tickThickness;\n          this.ctx.strokeStyle = this.tickColor;\n        }\n\n        var tickX = this.ctx.lineWidth % 2 === 1 ? (xy.x << 0) + .5 : xy.x << 0;\n        this.ctx.beginPath();\n        this.ctx.moveTo(tickX, xy.y << 0);\n        this.ctx.lineTo(tickX, xy.y + this.tickLength << 0);\n        this.ctx.stroke();\n      } //Don't skip stripLine's labels\n\n\n      if (skipLabels && labelCount++ % 2 !== 0 && !this._labels[i].stripLine) continue;\n\n      if (label.textBlock.angle === 0) {\n        xy.x -= label.textBlock.width / 2; //xy.y += this.tickLength + label.textBlock.height / 2;\n\n        xy.y += this.tickLength + label.textBlock.fontSize / 2;\n      } else {\n        xy.x -= this.labelAngle < 0 ? label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0;\n        xy.y += this.tickLength + Math.abs(this.labelAngle < 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5);\n      }\n\n      label.textBlock.x = xy.x;\n      label.textBlock.y = xy.y;\n      label.textBlock.render(true);\n    }\n\n    if (this.title) {\n      this._titleTextBlock = new TextBlock(this.ctx, {\n        x: this.lineCoordinates.x1,\n        // This is recalculated again\n        y: this.boundingRect.y2 - this.titleFontSize - 5,\n        // This is recalculated again\n        maxWidth: this.lineCoordinates.width,\n        maxHeight: this.titleFontSize * 1.5,\n        angle: 0,\n        text: this.title,\n        horizontalAlign: \"center\",\n        //left, center, right\n        fontSize: this.titleFontSize,\n        //in pixels\n        fontFamily: this.titleFontFamily,\n        fontWeight: this.titleFontWeight,\n        //normal, bold, bolder, lighter,\n        fontColor: this.titleFontColor,\n        fontStyle: this.titleFontStyle,\n        // normal, italic, oblique\n        textBaseline: \"top\"\n      });\n\n      this._titleTextBlock.measureText();\n\n      this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2;\n      this._titleTextBlock.y = this.boundingRect.y2 - this._titleTextBlock.height - 3;\n\n      this._titleTextBlock.render(true);\n    }\n  } else if (this._position === \"top\") {\n    var i = 0;\n    var label;\n    var xy;\n    var stripLine;\n\n    for (i = 0; i < this._labels.length; i++) {\n      label = this._labels[i];\n      if (label.position < this.viewportMinimum || label.position > this.viewportMaximum) continue;\n      xy = this.getPixelCoordinatesOnAxis(label.position);\n\n      if (this.tickThickness && !this._labels[i].stripLine || this._labels[i].stripLine && this._labels[i].stripLine._thicknessType === \"pixel\") {\n        if (this._labels[i].stripLine) {\n          stripLine = this._labels[i].stripLine;\n          this.ctx.lineWidth = stripLine.thickness;\n          this.ctx.strokeStyle = stripLine.color;\n        } else {\n          this.ctx.lineWidth = this.tickThickness;\n          this.ctx.strokeStyle = this.tickColor;\n        }\n\n        var tickX = this.ctx.lineWidth % 2 === 1 ? (xy.x << 0) + .5 : xy.x << 0;\n        this.ctx.beginPath();\n        this.ctx.moveTo(tickX, xy.y << 0);\n        this.ctx.lineTo(tickX, xy.y - this.tickLength << 0);\n        this.ctx.stroke();\n      } //Don't skip stripLine's labels\n\n\n      if (skipLabels && labelCount++ % 2 !== 0 && !this._labels[i].stripLine) continue;\n\n      if (label.textBlock.angle === 0) {\n        xy.x -= label.textBlock.width / 2;\n        xy.y -= this.tickLength + label.textBlock.height / 2;\n      } else {\n        xy.x -= this.labelAngle > 0 ? label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0;\n        xy.y -= this.tickLength + Math.abs(this.labelAngle > 0 ? label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5 : 5);\n      }\n\n      label.textBlock.x = xy.x;\n      label.textBlock.y = xy.y;\n      label.textBlock.render(true);\n    }\n\n    if (this.title) {\n      this._titleTextBlock = new TextBlock(this.ctx, {\n        x: this.lineCoordinates.x1,\n        // This is recalculated again\n        y: this.boundingRect.y1 + 1,\n        maxWidth: this.lineCoordinates.width,\n        maxHeight: this.titleFontSize * 1.5,\n        angle: 0,\n        text: this.title,\n        horizontalAlign: \"center\",\n        //left, center, right\n        fontSize: this.titleFontSize,\n        //in pixels\n        fontFamily: this.titleFontFamily,\n        fontWeight: this.titleFontWeight,\n        //normal, bold, bolder, lighter,\n        fontColor: this.titleFontColor,\n        fontStyle: this.titleFontStyle,\n        // normal, italic, oblique\n        textBaseline: \"top\"\n      });\n\n      this._titleTextBlock.measureText();\n\n      this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2;\n\n      this._titleTextBlock.render(true);\n    }\n  } else if (this._position === \"left\") {\n    var label;\n    var xy;\n\n    for (var i = 0; i < this._labels.length; i++) {\n      label = this._labels[i];\n      if (label.position < this.viewportMinimum || label.position > this.viewportMaximum) continue;\n      xy = this.getPixelCoordinatesOnAxis(label.position);\n\n      if (this.tickThickness && !this._labels[i].stripLine || this._labels[i].stripLine && this._labels[i].stripLine._thicknessType === \"pixel\") {\n        if (this._labels[i].stripLine) {\n          stripLine = this._labels[i].stripLine;\n          this.ctx.lineWidth = stripLine.thickness;\n          this.ctx.strokeStyle = stripLine.color;\n        } else {\n          this.ctx.lineWidth = this.tickThickness;\n          this.ctx.strokeStyle = this.tickColor;\n        }\n\n        var tickY = this.ctx.lineWidth % 2 === 1 ? (xy.y << 0) + .5 : xy.y << 0;\n        this.ctx.beginPath();\n        this.ctx.moveTo(xy.x << 0, tickY);\n        this.ctx.lineTo(xy.x - this.tickLength << 0, tickY);\n        this.ctx.stroke();\n      } //Don't skip stripLine's labels\n\n\n      if (skipLabels && labelCount++ % 2 !== 0 && !this._labels[i].stripLine) continue;\n      label.textBlock.x = xy.x - label.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5;\n\n      if (this.labelAngle === 0) {\n        label.textBlock.y = xy.y;\n      } else label.textBlock.y = xy.y - label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle);\n\n      label.textBlock.render(true);\n    }\n\n    if (this.title) {\n      this._titleTextBlock = new TextBlock(this.ctx, {\n        x: this.boundingRect.x1 + 1,\n        y: this.lineCoordinates.y2,\n        maxWidth: this.lineCoordinates.height,\n        maxHeight: this.titleFontSize * 1.5,\n        angle: -90,\n        text: this.title,\n        horizontalAlign: \"center\",\n        //left, center, right\n        fontSize: this.titleFontSize,\n        //in pixels\n        fontFamily: this.titleFontFamily,\n        fontWeight: this.titleFontWeight,\n        //normal, bold, bolder, lighter,\n        fontColor: this.titleFontColor,\n        fontStyle: this.titleFontStyle,\n        // normal, italic, oblique\n        textBaseline: \"top\"\n      });\n\n      var size = this._titleTextBlock.measureText(); //this._titleTextBlock.x -= 4;\n\n\n      this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1;\n\n      this._titleTextBlock.render(true); //if (isDebugMode) {\n      //\twindow.console.log(\"titleFontSize: \" + this.titleFontSize + \"; width: \" + size.width + \"; height: \" + size.height);\n      //\twindow.console.log(\"this.boundingRect.x1: \" + this.boundingRect.x1);\n      //\t//this.ctx.rect(this._titleTextBlock.x, this._titleTextBlock.y, this._titleTextBlock.height, -this._titleTextBlock.width);\n      //\t//this.ctx.stroke();\n      //}\n\n    }\n  } else if (this._position === \"right\") {\n    var label;\n    var xy;\n\n    for (var i = 0; i < this._labels.length; i++) {\n      label = this._labels[i];\n      if (label.position < this.viewportMinimum || label.position > this.viewportMaximum) continue;\n      xy = this.getPixelCoordinatesOnAxis(label.position);\n\n      if (this.tickThickness && !this._labels[i].stripLine || this._labels[i].stripLine && this._labels[i].stripLine._thicknessType === \"pixel\") {\n        if (this._labels[i].stripLine) {\n          stripLine = this._labels[i].stripLine;\n          this.ctx.lineWidth = stripLine.thickness;\n          this.ctx.strokeStyle = stripLine.color;\n        } else {\n          this.ctx.lineWidth = this.tickThickness;\n          this.ctx.strokeStyle = this.tickColor;\n        }\n\n        var tickY = this.ctx.lineWidth % 2 === 1 ? (xy.y << 0) + .5 : xy.y << 0;\n        this.ctx.beginPath();\n        this.ctx.moveTo(xy.x << 0, tickY);\n        this.ctx.lineTo(xy.x + this.tickLength << 0, tickY);\n        this.ctx.stroke();\n      } //Don't skip stripLine's labels\n\n\n      if (skipLabels && labelCount++ % 2 !== 0 && !this._labels[i].stripLine) continue;\n      label.textBlock.x = xy.x + this.tickLength + 5; //label.textBlock.y = xy.y - (label.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle));\n\n      if (this.labelAngle === 0) {\n        label.textBlock.y = xy.y;\n      } else label.textBlock.y = xy.y;\n\n      label.textBlock.render(true);\n    }\n\n    if (this.title) {\n      this._titleTextBlock = new TextBlock(this.ctx, {\n        x: this.boundingRect.x2 - 1,\n        y: this.lineCoordinates.y2,\n        maxWidth: this.lineCoordinates.height,\n        maxHeight: this.titleFontSize * 1.5,\n        angle: 90,\n        text: this.title,\n        horizontalAlign: \"center\",\n        //left, center, right\n        fontSize: this.titleFontSize,\n        //in pixels\n        fontFamily: this.titleFontFamily,\n        fontWeight: this.titleFontWeight,\n        //normal, bold, bolder, lighter,\n        fontColor: this.titleFontColor,\n        fontStyle: this.titleFontStyle,\n        // normal, italic, oblique\n        textBaseline: \"top\"\n      });\n\n      this._titleTextBlock.measureText();\n\n      this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1;\n\n      this._titleTextBlock.render(true);\n    }\n  }\n};\n\nAxis.prototype.renderInterlacedColors = function () {\n  var ctx = this.chart.plotArea.ctx; //return;\n\n  var interlacedGridStartPoint;\n  var interlacedGridEndPoint;\n  var plotAreaCoordinates = this.chart.plotArea;\n  var i = 0,\n      renderInterlacedGrid = true;\n\n  if ((this._position === \"bottom\" || this._position === \"top\") && this.interlacedColor) {\n    ctx.fillStyle = this.interlacedColor;\n\n    for (i = 0; i < this._labels.length; i++) {\n      if (this._labels[i].stripLine) continue;\n\n      if (renderInterlacedGrid) {\n        //So that the interlaced color alternates\n        interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this._labels[i].position);\n        if (i + 1 >= this._labels.length - 1) interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this.viewportMaximum);else interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this._labels[i + 1].position);\n        ctx.fillRect(interlacedGridStartPoint.x, plotAreaCoordinates.y1, Math.abs(interlacedGridEndPoint.x - interlacedGridStartPoint.x), Math.abs(plotAreaCoordinates.y1 - plotAreaCoordinates.y2));\n        renderInterlacedGrid = false;\n      } else renderInterlacedGrid = true;\n    }\n  } else if ((this._position === \"left\" || this._position === \"right\") && this.interlacedColor) {\n    ctx.fillStyle = this.interlacedColor;\n\n    for (i = 0; i < this._labels.length; i++) {\n      if (this._labels[i].stripLine) continue;\n\n      if (renderInterlacedGrid) {\n        //So that the interlaced color alternates\n        interlacedGridEndPoint = this.getPixelCoordinatesOnAxis(this._labels[i].position);\n        if (i + 1 >= this._labels.length - 1) interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this.viewportMaximum);else interlacedGridStartPoint = this.getPixelCoordinatesOnAxis(this._labels[i + 1].position);\n        ctx.fillRect(plotAreaCoordinates.x1, interlacedGridStartPoint.y, Math.abs(plotAreaCoordinates.x1 - plotAreaCoordinates.x2), Math.abs(interlacedGridStartPoint.y - interlacedGridEndPoint.y));\n        renderInterlacedGrid = false;\n      } else renderInterlacedGrid = true;\n    } //throw \"123\";\n\n  }\n\n  ctx.beginPath();\n}; //Renders stripLines of given thickness type.\n\n\nAxis.prototype.renderStripLinesOfThicknessType = function (thicknessType) {\n  if (!(this.stripLines && this.stripLines.length > 0) || !thicknessType) return;\n\n  var _this = this;\n\n  var i = 0;\n\n  for (i = 0; i < this.stripLines.length; i++) {\n    var stripLine = this.stripLines[i];\n    if (stripLine._thicknessType !== thicknessType) continue; //Should be skipped only if thicknessType is \"pixel\". If it is \"value\" then clipping is automatically applied before calling.\n\n    if (thicknessType === \"pixel\" && (stripLine.value < this.viewportMinimum || stripLine.value > this.viewportMaximum)) continue;\n\n    if (stripLine.showOnTop) {\n      this.chart.addEventListener(\"dataAnimationIterationEnd\", stripLine.render, stripLine);\n    } else stripLine.render();\n  }\n};\n\nAxis.prototype.renderGrid = function () {\n  if (!(this.gridThickness && this.gridThickness > 0)) return; //var ctx = this.chart.plotArea.ctx;\n\n  var ctx = this.chart.ctx;\n  var xy;\n  var plotAreaCoordinates = this.chart.plotArea;\n  var stripLine;\n  var tempLineWidth, tempStrokeStyle; //return;\n\n  ctx.lineWidth = this.gridThickness;\n  ctx.strokeStyle = this.gridColor;\n\n  if (ctx.setLineDash) {\n    ctx.setLineDash(getLineDashArray(this.gridDashType, this.gridThickness));\n  }\n\n  if (this._position === \"bottom\" || this._position === \"top\") {\n    for (i = 0; i < this._labels.length && !this._labels[i].stripLine; i++) {\n      if (this._labels[i].position < this.viewportMinimum || this._labels[i].position > this.viewportMaximum) continue;\n      ctx.beginPath();\n      xy = this.getPixelCoordinatesOnAxis(this._labels[i].position);\n      var gridX = ctx.lineWidth % 2 === 1 ? (xy.x << 0) + .5 : xy.x << 0;\n      ctx.moveTo(gridX, plotAreaCoordinates.y1 << 0);\n      ctx.lineTo(gridX, plotAreaCoordinates.y2 << 0);\n      ctx.stroke();\n    }\n  } else if (this._position === \"left\" || this._position === \"right\") {\n    for (var i = 0; i < this._labels.length && !this._labels[i].stripLine; i++) {\n      if (i === 0 && this.type === \"axisY\" && this.chart.axisX && this.chart.axisX.lineThickness) continue;\n      if (this._labels[i].position < this.viewportMinimum || this._labels[i].position > this.viewportMaximum) continue;\n      ctx.beginPath();\n      xy = this.getPixelCoordinatesOnAxis(this._labels[i].position);\n      var gridY = ctx.lineWidth % 2 === 1 ? (xy.y << 0) + .5 : xy.y << 0;\n      ctx.moveTo(plotAreaCoordinates.x1 << 0, gridY);\n      ctx.lineTo(plotAreaCoordinates.x2 << 0, gridY);\n      ctx.stroke();\n    }\n  }\n};\n\nAxis.prototype.renderAxisLine = function () {\n  //var ctx = this.chart.plotArea.ctx;\n  var ctx = this.chart.ctx;\n\n  if (this._position === \"bottom\" || this._position === \"top\") {\n    if (this.lineThickness) {\n      ctx.lineWidth = this.lineThickness;\n      ctx.strokeStyle = this.lineColor ? this.lineColor : \"black\";\n\n      if (ctx.setLineDash) {\n        ctx.setLineDash(getLineDashArray(this.lineDashType, this.lineThickness));\n      }\n\n      var lineY = this.lineThickness % 2 === 1 ? (this.lineCoordinates.y1 << 0) + .5 : this.lineCoordinates.y1 << 0;\n      ctx.beginPath();\n      ctx.moveTo(this.lineCoordinates.x1, lineY);\n      ctx.lineTo(this.lineCoordinates.x2, lineY);\n      ctx.stroke();\n    }\n  } else if (this._position === \"left\" || this._position === \"right\") {\n    if (this.lineThickness) {\n      ctx.lineWidth = this.lineThickness;\n      ctx.strokeStyle = this.lineColor;\n\n      if (ctx.setLineDash) {\n        ctx.setLineDash(getLineDashArray(this.lineDashType, this.lineThickness));\n      }\n\n      var lineX = this.lineThickness % 2 === 1 ? (this.lineCoordinates.x1 << 0) + .5 : this.lineCoordinates.x1 << 0;\n      ctx.beginPath();\n      ctx.moveTo(lineX, this.lineCoordinates.y1);\n      ctx.lineTo(lineX, this.lineCoordinates.y2);\n      ctx.stroke();\n    }\n  }\n};\n\nAxis.prototype.getPixelCoordinatesOnAxis = function (value) {\n  var xy = {};\n  var width = this.lineCoordinates.width;\n  var height = this.lineCoordinates.height;\n\n  if (this._position === \"bottom\" || this._position === \"top\") {\n    //var pixelPerUnit = width / Math.abs(this.viewportMaximum - this.viewportMinimum);\n    var pixelPerUnit = this.conversionParameters.pixelPerUnit; //xy.x = this.lineCoordinates.x1 + (pixelPerUnit * (value - this.viewportMinimum));\n\n    xy.x = this.conversionParameters.reference + pixelPerUnit * (value - this.viewportMinimum);\n    xy.y = this.lineCoordinates.y1;\n  }\n\n  if (this._position === \"left\" || this._position === \"right\") {\n    //var pixelPerUnit = height / Math.abs(this.viewportMaximum - this.viewportMinimum);\n    var pixelPerUnit = -this.conversionParameters.pixelPerUnit; //xy.y = this.lineCoordinates.y2 - (pixelPerUnit * (value - this.viewportMinimum));\n\n    xy.y = this.conversionParameters.reference - pixelPerUnit * (value - this.viewportMinimum);\n    xy.x = this.lineCoordinates.x2;\n  }\n\n  return xy;\n};\n\nAxis.prototype.convertPixelToValue = function (pixel) {\n  if (!pixel) return null;\n  var value = 0;\n  var p = this._position === \"left\" || this._position === \"right\" ? pixel.y : pixel.x;\n  value = this.conversionParameters.minimum + (p - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;\n  return value;\n};\n\nAxis.prototype.setViewPortRange = function (viewportMinimum, viewportMaximum) {\n  this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(viewportMinimum, viewportMaximum);\n  this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(viewportMinimum, viewportMaximum);\n};\n\nAxis.prototype.getXValueAt = function (pixel) {\n  if (!pixel) return null;\n  var xval = null;\n\n  if (this._position === \"left\") {\n    xval = (this.chart.axisX.viewportMaximum - this.chart.axisX.viewportMinimum) / this.chart.axisX.lineCoordinates.height * (this.chart.axisX.lineCoordinates.y2 - pixel.y) + this.chart.axisX.viewportMinimum;\n  } else if (this._position === \"bottom\") {\n    xval = (this.chart.axisX.viewportMaximum - this.chart.axisX.viewportMinimum) / this.chart.axisX.lineCoordinates.width * (pixel.x - this.chart.axisX.lineCoordinates.x1) + this.chart.axisX.viewportMinimum;\n  }\n\n  return xval;\n};\n\nAxis.prototype.calculateValueToPixelConversionParameters = function (value) {\n  this.reversed = false;\n  var conversionParameters = {\n    pixelPerUnit: null,\n    minimum: null,\n    reference: null\n  };\n  var width = this.lineCoordinates.width;\n  var height = this.lineCoordinates.height;\n  conversionParameters.minimum = this.viewportMinimum;\n\n  if (this._position === \"bottom\" || this._position === \"top\") {\n    conversionParameters.pixelPerUnit = (this.reversed ? -1 : 1) * width / Math.abs(this.viewportMaximum - this.viewportMinimum);\n    conversionParameters.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;\n  }\n\n  if (this._position === \"left\" || this._position === \"right\") {\n    conversionParameters.pixelPerUnit = (this.reversed ? 1 : -1) * height / Math.abs(this.viewportMaximum - this.viewportMinimum);\n    conversionParameters.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;\n  }\n\n  this.conversionParameters = conversionParameters;\n};\n\nAxis.prototype.calculateAxisParameters = function () {\n  var freeSpace = this.chart.layoutManager.getFreeSpace();\n  var availableWidth = 0;\n  var availableHeight = 0;\n  var isLessThanTwoDataPoints = false;\n\n  if (this._position === \"bottom\" || this._position === \"top\") {\n    this.maxWidth = freeSpace.width;\n    this.maxHeight = freeSpace.height;\n  } else {\n    this.maxWidth = freeSpace.height;\n    this.maxHeight = freeSpace.width;\n  }\n\n  var noTicks = this.type === \"axisX\" ? this.maxWidth < 500 ? 8 : Math.max(6, Math.floor(this.maxWidth / 62)) : Math.max(Math.floor(this.maxWidth / 40), 2);\n  var min, max;\n  var minDiff;\n  var range;\n  var rangePadding = 0;\n  if (this.viewportMinimum === null || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;\n  if (this.viewportMaximum === null || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;\n\n  if (this.type === \"axisX\") {\n    min = this.viewportMinimum !== null ? this.viewportMinimum : this.dataInfo.viewPortMin;\n    max = this.viewportMaximum !== null ? this.viewportMaximum : this.dataInfo.viewPortMax;\n\n    if (max - min === 0) {\n      rangePadding = typeof this._options.interval === \"undefined\" ? .4 : this._options.interval;\n      max += rangePadding;\n      min -= rangePadding;\n    }\n\n    if (this.dataInfo.minDiff !== Infinity) minDiff = this.dataInfo.minDiff;else if (max - min > 1) {\n      minDiff = Math.abs(max - min) * .5;\n    } else {\n      minDiff = 1;\n      if (this.chart.plotInfo.axisXValueType === \"dateTime\") isLessThanTwoDataPoints = true;\n    }\n  } else if (this.type === \"axisY\") {\n    //min = typeof (this._options.viewportMinimum) === \"undefined\" || this._options.viewportMinimum === null ? this.dataInfo.viewPortMin : this._options.viewportMinimum;\n    //max = typeof (this._options.viewportMaximum) === \"undefined\" || this._options.viewportMaximum === null ? this.dataInfo.viewPortMax : this._options.viewportMaximum;\n    min = this.viewportMinimum !== null ? this.viewportMinimum : this.dataInfo.viewPortMin;\n    max = this.viewportMaximum !== null ? this.viewportMaximum : this.dataInfo.viewPortMax;\n\n    if (!isFinite(min) && !isFinite(max)) {\n      max = typeof this._options.interval === \"undefined\" ? -Infinity : this._options.interval;\n      min = 0;\n    } else if (!isFinite(min)) {\n      min = max;\n    } else if (!isFinite(max)) {\n      max = min;\n    }\n\n    if (min === 0 && max === 0) {\n      // When all dataPoints are zero\n      max += 9;\n      min = 0;\n    } else if (max - min === 0) {\n      // When there is only a single dataPoint or when all dataPoints have same Y Value\n      rangePadding = Math.min(Math.abs(Math.abs(max) * .01), 5);\n      max += rangePadding;\n      min -= rangePadding;\n    } else if (min > max) {\n      rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), 5);\n      if (max >= 0) min = max - rangePadding;else max = min + rangePadding;\n    } else {\n      rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), .05);\n      if (max !== 0) max += rangePadding;\n      if (min !== 0) min -= rangePadding;\n    }\n\n    if (this.dataInfo.minDiff !== Infinity) minDiff = this.dataInfo.minDiff;else if (max - min > 1) {\n      minDiff = Math.abs(max - min) * .5;\n    } else {\n      minDiff = 1;\n    } //Apply includeZero\n\n    if (this.includeZero && (this.viewportMinimum === null || isNaN(this.viewportMinimum))) {\n      if (min > 0) min = 0;\n    }\n\n    if (this.includeZero && (this.viewportMaximum === null || isNaN(this.viewportMaximum))) {\n      if (max < 0) max = 0;\n    }\n  }\n\n  range = (isNaN(this.viewportMaximum) || this.viewportMaximum === null ? max : this.viewportMaximum) - (isNaN(this.viewportMinimum) || this.viewportMinimum === null ? min : this.viewportMinimum);\n\n  if (this.type === \"axisX\" && this.chart.plotInfo.axisXValueType === \"dateTime\") {\n    if (!this.intervalType) {\n      if (range / (1 * 1) <= noTicks) {\n        this.interval = 1;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 2) <= noTicks) {\n        this.interval = 2;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 5) <= noTicks) {\n        this.interval = 5;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 10) <= noTicks) {\n        this.interval = 10;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 20) <= noTicks) {\n        this.interval = 20;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 50) <= noTicks) {\n        this.interval = 50;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 100) <= noTicks) {\n        this.interval = 100;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 200) <= noTicks) {\n        this.interval = 200;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 250) <= noTicks) {\n        this.interval = 250;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 300) <= noTicks) {\n        this.interval = 300;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 400) <= noTicks) {\n        this.interval = 400;\n        this.intervalType = \"millisecond\";\n      } else if (range / (1 * 500) <= noTicks) {\n        this.interval = 500;\n        this.intervalType = \"millisecond\";\n      } else if (range / (constants.secondDuration * 1) <= noTicks) {\n        this.interval = 1;\n        this.intervalType = \"second\";\n      } else if (range / (constants.secondDuration * 2) <= noTicks) {\n        this.interval = 2;\n        this.intervalType = \"second\";\n      } else if (range / (constants.secondDuration * 5) <= noTicks) {\n        this.interval = 5;\n        this.intervalType = \"second\";\n      } else if (range / (constants.secondDuration * 10) <= noTicks) {\n        this.interval = 10;\n        this.intervalType = \"second\";\n      } else if (range / (constants.secondDuration * 15) <= noTicks) {\n        this.interval = 15;\n        this.intervalType = \"second\";\n      } else if (range / (constants.secondDuration * 20) <= noTicks) {\n        this.interval = 20;\n        this.intervalType = \"second\";\n      } else if (range / (constants.secondDuration * 30) <= noTicks) {\n        this.interval = 30;\n        this.intervalType = \"second\";\n      } else if (range / (constants.minuteDuration * 1) <= noTicks) {\n        this.interval = 1;\n        this.intervalType = \"minute\";\n      } else if (range / (constants.minuteDuration * 2) <= noTicks) {\n        this.interval = 2;\n        this.intervalType = \"minute\";\n      } else if (range / (constants.minuteDuration * 5) <= noTicks) {\n        this.interval = 5;\n        this.intervalType = \"minute\";\n      } else if (range / (constants.minuteDuration * 10) <= noTicks) {\n        this.interval = 10;\n        this.intervalType = \"minute\";\n      } else if (range / (constants.minuteDuration * 15) <= noTicks) {\n        this.interval = 15;\n        this.intervalType = \"minute\";\n      } else if (range / (constants.minuteDuration * 20) <= noTicks) {\n        this.interval = 20;\n        this.intervalType = \"minute\";\n      } else if (range / (constants.minuteDuration * 30) <= noTicks) {\n        this.interval = 30;\n        this.intervalType = \"minute\";\n      } else if (range / (constants.hourDuration * 1) <= noTicks) {\n        this.interval = 1;\n        this.intervalType = \"hour\";\n      } else if (range / (constants.hourDuration * 2) <= noTicks) {\n        this.interval = 2;\n        this.intervalType = \"hour\";\n      } else if (range / (constants.hourDuration * 3) <= noTicks) {\n        this.interval = 3;\n        this.intervalType = \"hour\";\n      } else if (range / (constants.hourDuration * 6) <= noTicks) {\n        this.interval = 6;\n        this.intervalType = \"hour\";\n      } else if (range / (constants.dayDuration * 1) <= noTicks) {\n        this.interval = 1;\n        this.intervalType = \"day\";\n      } else if (range / (constants.dayDuration * 2) <= noTicks) {\n        this.interval = 2;\n        this.intervalType = \"day\";\n      } else if (range / (constants.dayDuration * 4) <= noTicks) {\n        this.interval = 4;\n        this.intervalType = \"day\";\n      } else if (range / (constants.weekDuration * 1) <= noTicks) {\n        this.interval = 1;\n        this.intervalType = \"week\";\n      } else if (range / (constants.weekDuration * 2) <= noTicks) {\n        this.interval = 2;\n        this.intervalType = \"week\";\n      } else if (range / (constants.weekDuration * 3) <= noTicks) {\n        this.interval = 3;\n        this.intervalType = \"week\";\n      } else if (range / (constants.monthDuration * 1) <= noTicks) {\n        this.interval = 1;\n        this.intervalType = \"month\";\n      } else if (range / (constants.monthDuration * 2) <= noTicks) {\n        this.interval = 2;\n        this.intervalType = \"month\";\n      } else if (range / (constants.monthDuration * 3) <= noTicks) {\n        this.interval = 3;\n        this.intervalType = \"month\";\n      } else if (range / (constants.monthDuration * 6) <= noTicks) {\n        this.interval = 6;\n        this.intervalType = \"month\";\n      } else if (range / (constants.yearDuration * 1) <= noTicks) {\n        this.interval = 1;\n        this.intervalType = \"year\";\n      } else if (range / (constants.yearDuration * 2) <= noTicks) {\n        this.interval = 2;\n        this.intervalType = \"year\";\n      } else if (range / (constants.yearDuration * 4) <= noTicks) {\n        this.interval = 4;\n        this.intervalType = \"year\";\n      } else {\n        this.interval = Math.floor(Axis.getNiceNumber(range / (noTicks - 1), true) / constants.yearDuration);\n        this.intervalType = \"year\";\n      }\n    }\n\n    if (this.viewportMinimum === null || isNaN(this.viewportMinimum)) this.viewportMinimum = min - minDiff / 2;\n    if (this.viewportMaximum === null || isNaN(this.viewportMaximum)) this.viewportMaximum = max + minDiff / 2;\n\n    if (!this.valueFormatString) {\n      if (isLessThanTwoDataPoints) {\n        this.valueFormatString = \"MMM DD YYYY HH:mm\";\n      } else if (this.intervalType === \"year\") {\n        this.valueFormatString = \"YYYY\";\n      } else if (this.intervalType === \"month\") {\n        this.valueFormatString = \"MMM YYYY\";\n      } else if (this.intervalType === \"week\") {\n        this.valueFormatString = \"MMM DD YYYY\";\n      } else if (this.intervalType === \"day\") {\n        this.valueFormatString = \"MMM DD YYYY\";\n      } else if (this.intervalType === \"hour\") {\n        this.valueFormatString = \"hh:mm TT\";\n      } else if (this.intervalType === \"minute\") {\n        this.valueFormatString = \"hh:mm TT\";\n      } else if (this.intervalType === \"second\") {\n        this.valueFormatString = \"hh:mm:ss TT\";\n      } else if (this.intervalType === \"millisecond\") {\n        this.valueFormatString = \"fff'ms'\";\n      }\n    }\n  } else {\n    this.intervalType = \"number\";\n    range = Axis.getNiceNumber(range, false);\n    if (this._options && this._options.interval) this.interval = this._options.interval;else {\n      this.interval = Axis.getNiceNumber(range / (noTicks - 1), true);\n    }\n\n    if (this.viewportMinimum === null || isNaN(this.viewportMinimum)) {\n      if (this.type === \"axisX\") this.viewportMinimum = min - minDiff / 2;else this.viewportMinimum = Math.floor(min / this.interval) * this.interval;\n    }\n\n    if (this.viewportMaximum === null || isNaN(this.viewportMaximum)) {\n      if (this.type === \"axisX\") this.viewportMaximum = max + minDiff / 2;else this.viewportMaximum = Math.ceil(max / this.interval) * this.interval;\n    }\n\n    if (this.viewportMaximum === 0 && this.viewportMinimum === 0) {\n      if (this._options.viewportMinimum === 0) {\n        this.viewportMaximum += 10;\n      } else if (this._options.viewportMaximum === 0) {\n        this.viewportMinimum -= 10;\n      }\n\n      if (this._options && typeof this._options.interval === \"undefined\") {\n        this.interval = Axis.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (noTicks - 1), true);\n      }\n    }\n  } //Calculate minimum and maximum if not provided by the user\n\n\n  if (this.minimum === null || this.maximum === null) {\n    if (this.type === \"axisX\") {\n      min = this.minimum !== null ? this.minimum : this.dataInfo.min;\n      max = this.maximum !== null ? this.maximum : this.dataInfo.max;\n\n      if (max - min === 0) {\n        rangePadding = typeof this._options.interval === \"undefined\" ? .4 : this._options.interval;\n        max += rangePadding;\n        min -= rangePadding;\n      }\n\n      if (this.dataInfo.minDiff !== Infinity) minDiff = this.dataInfo.minDiff;else if (max - min > 1) {\n        minDiff = Math.abs(max - min) * .5;\n      } else {\n        minDiff = 1;\n      }\n    } else if (this.type === \"axisY\") {\n      min = this.minimum !== null ? this.minimum : this.dataInfo.min;\n      max = this.maximum !== null ? this.maximum : this.dataInfo.max;\n\n      if (!isFinite(min) && !isFinite(max)) {\n        max = typeof this._options.interval === \"undefined\" ? -Infinity : this._options.interval;\n        min = 0;\n      } else if (min === 0 && max === 0) {\n        // When all dataPoints are zero\n        max += 9;\n        min = 0;\n      } else if (max - min === 0) {\n        // When there is only a single dataPoint or when all dataPoints have same Y Value\n        rangePadding = Math.min(Math.abs(Math.abs(max) * .01), 5);\n        max += rangePadding;\n        min -= rangePadding;\n      } else if (min > max) {\n        rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), 5);\n        if (max >= 0) min = max - rangePadding;else max = min + rangePadding;\n      } else {\n        rangePadding = Math.min(Math.abs(Math.abs(max - min) * .01), .05);\n        if (max !== 0) max += rangePadding;\n        if (min !== 0) min -= rangePadding;\n      }\n\n      if (this.dataInfo.minDiff !== Infinity) minDiff = this.dataInfo.minDiff;else if (max - min > 1) {\n        minDiff = Math.abs(max - min) * .5;\n      } else {\n        minDiff = 1;\n      } //Apply includeZero\n\n      if (this.includeZero && (this.minimum === null || isNaN(this.minimum))) {\n        if (min > 0) min = 0;\n      }\n\n      if (this.includeZero && (this.maximum === null || isNaN(this.maximum))) {\n        if (max < 0) max = 0;\n      }\n    }\n\n    range = max - min;\n\n    if (this.type === \"axisX\" && this.chart.plotInfo.axisXValueType === \"dateTime\") {\n      if (this.minimum === null || isNaN(this.minimum)) this.minimum = min - minDiff / 2;\n      if (this.maximum === null || isNaN(this.maximum)) this.maximum = max + minDiff / 2;\n    } else {\n      this.intervalType = \"number\";\n\n      if (this.minimum === null) {\n        if (this.type === \"axisX\") this.minimum = min - minDiff / 2;else this.minimum = Math.floor(min / this.interval) * this.interval;\n        this.minimum = Math.min(this.minimum, this.sessionVariables.viewportMinimum === null || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum);\n      }\n\n      if (this.maximum === null) {\n        if (this.type === \"axisX\") this.maximum = max + minDiff / 2;else this.maximum = Math.ceil(max / this.interval) * this.interval;\n        this.maximum = Math.max(this.maximum, this.sessionVariables.viewportMaximum === null || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum);\n      } //var nfrac = Math.max(-Math.floor(Math.log(d)/Math.LN10), 0); //number of fractional digits to show\n\n\n      if (this.maximum === 0 && this.minimum === 0) {\n        if (this._options.minimum === 0) {\n          this.maximum += 10;\n        } else if (this._options.maximum === 0) {\n          this.minimum -= 10;\n        }\n      }\n    }\n  }\n\n  this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);\n  this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);\n  if (this.type === \"axisX\" && this.chart.plotInfo.axisXValueType === \"dateTime\") this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval);else this.intervalStartPosition = Math.floor((this.viewportMinimum + this.interval * .2) / this.interval) * this.interval; //Set valueFormatString\n\n  if (!this.valueFormatString) {\n    this.valueFormatString = \"#,##0.##\";\n    range = Math.abs(this.viewportMaximum - this.viewportMinimum);\n\n    if (range < 1) {\n      var numberOfDecimals = Math.floor(Math.abs(Math.log(range) / Math.LN10)) + 2;\n      if (isNaN(numberOfDecimals) || !isFinite(numberOfDecimals)) numberOfDecimals = 2;\n\n      if (numberOfDecimals > 2) {\n        for (var i = 0; i < numberOfDecimals - 2; i++) this.valueFormatString += \"#\";\n      }\n    }\n  } //if (isDebugMode && window.console) {\n  //    window.console.log(this.type + \": Min = \" + this.viewportMinimum);\n  //    window.console.log(this.type + \": Max = \" + this.viewportMaximum);\n  //    window.console.log(this.type + \": Interval = \" + this.interval);\n  //}\n\n};\n\nAxis.getNiceNumber = function (x, round) {\n  var exp = Math.floor(Math.log(x) / Math.LN10);\n  var f = x / Math.pow(10, exp);\n  var nf;\n\n  if (round) {\n    if (f < 1.5) nf = 1;else if (f < 3) nf = 2;else if (f < 7) nf = 5;else nf = 10;\n  } else {\n    if (f <= 1) nf = 1;else if (f <= 2) nf = 2;else if (f <= 5) nf = 5;else nf = 10;\n  }\n\n  return Number((nf * Math.pow(10, exp)).toFixed(20));\n};\n\nAxis.prototype.getLabelStartPoint = function () {\n  var intervalInMilliseconds = convertToNumber(this.interval, this.intervalType);\n  var minimum = Math.floor(this.viewportMinimum / intervalInMilliseconds) * intervalInMilliseconds;\n  var dateTime = new Date(minimum);\n\n  if (this.intervalType === \"millisecond\") {//millisecond = dateTime.getMilliSecond();\n    //millisecond = Math.floor((millisecond + this.interval) / this.interval) * this.interval;\n  } else if (this.intervalType === \"second\") {\n    if (dateTime.getMilliseconds() > 0) {\n      dateTime.setSeconds(dateTime.getSeconds() + 1);\n      dateTime.setMilliseconds(0);\n    }\n  } else if (this.intervalType === \"minute\") {\n    if (dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {\n      dateTime.setMinutes(dateTime.getMinutes() + 1);\n      dateTime.setSeconds(0);\n      dateTime.setMilliseconds(0);\n    }\n  } else if (this.intervalType === \"hour\") {\n    if (dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {\n      dateTime.setHours(dateTime.getHours() + 1);\n      dateTime.setMinutes(0);\n      dateTime.setSeconds(0);\n      dateTime.setMilliseconds(0);\n    }\n  } else if (this.intervalType === \"day\") {\n    if (dateTime.getHours() > 0 || dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {\n      dateTime.setDate(dateTime.getDate() + 1);\n      dateTime.setHours(0);\n      dateTime.setMinutes(0);\n      dateTime.setSeconds(0);\n      dateTime.setMilliseconds(0);\n    }\n  } else if (this.intervalType === \"week\") {\n    if (dateTime.getDay() > 0 || dateTime.getHours() > 0 || dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {\n      dateTime.setDate(dateTime.getDate() + (7 - dateTime.getDay()));\n      dateTime.setHours(0);\n      dateTime.setMinutes(0);\n      dateTime.setSeconds(0);\n      dateTime.setMilliseconds(0);\n    }\n  } else if (this.intervalType === \"month\") {\n    if (dateTime.getDate() > 1 || dateTime.getHours() > 0 || dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {\n      dateTime.setMonth(dateTime.getMonth() + 1);\n      dateTime.setDate(1);\n      dateTime.setHours(0);\n      dateTime.setMinutes(0);\n      dateTime.setSeconds(0);\n      dateTime.setMilliseconds(0);\n    }\n  } else if (this.intervalType === \"year\") {\n    if (dateTime.getMonth() > 0 || dateTime.getDate() > 1 || dateTime.getHours() > 0 || dateTime.getMinutes() > 0 || dateTime.getSeconds() > 0 || dateTime.getMilliseconds() > 0) {\n      dateTime.setFullYear(dateTime.getFullYear() + 1);\n      dateTime.setMonth(0);\n      dateTime.setDate(1);\n      dateTime.setHours(0);\n      dateTime.setMinutes(0);\n      dateTime.setSeconds(0);\n      dateTime.setMilliseconds(0);\n    }\n  }\n\n  return dateTime;\n};\n\nexport default Axis;","map":null,"metadata":{},"sourceType":"module"}