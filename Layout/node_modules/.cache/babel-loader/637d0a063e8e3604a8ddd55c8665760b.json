{"ast":null,"code":"import CanvasJSObject from './canvasjs';\nimport Animator from './animator';\nimport DataSeries from './data_series';\nimport TextBlock from './text_block';\nimport RenderHelper from '../helpers/render';\nimport LayoutManager from './layout_manager';\nimport EventManager from './event_manager';\nimport ToolTip from './tooltip';\nimport CultureInfo from '../core/culture_info';\nimport Axis from '../core/axis';\nimport Title from '../core/title';\nimport Legend from '../core/legend';\nimport AnimationHelper from '../helpers/animator';\nimport { colorSets } from '../constants/themes';\nimport { isDebugMode, defaultOptions } from '../constants/options'; // import {inherits} from 'util';\n\nimport { addEvent, setCanvasSize, addArrayIndexOf, hide, show, getMouseCoordinates, getProperty, isCanvasSupported, extend, createCanvas, extendCtx, getObjectId, devicePixelBackingStoreRatio, trimString, numberFormat, getLineDashArray, intToHexColorString, compareDataPointX } from '../helpers/utils';\nimport { SplineChart, ColumnChart, StackedColumnChart, StackedColumn100Chart, BarChart, StackedBarChart, StackedBar100Chart, AreaChart, SplineAreaChart, StepAreaChart, StackedAreaChart, StackedArea100Chart, BubbleChart, ScatterChart, CandlestickChart, RangeColumnChart, RangeBarChart, RangeAreaChart, RangeSplineAreaChart, PieChart } from '../charts/index';\n\nfunction Chart(containerId, options, publicChartReference) {\n  this._publicChartReference = publicChartReference;\n  options = options || {};\n  Chart.base.constructor.call(this, \"Chart\", options, options.theme ? options.theme : \"theme1\");\n\n  var _this = this;\n\n  this._containerId = containerId;\n  this._objectsInitialized = false;\n  this.ctx = null;\n  this.overlaidCanvasCtx = null;\n  this._indexLabels = [];\n  this._panTimerId = 0;\n  this._lastTouchEventType = \"\";\n  this._lastTouchData = null;\n  this.isAnimating = false;\n  this.renderCount = 0;\n  this.animatedRender = false;\n  this.disableToolTip = false;\n  this.panEnabled = false;\n  this._defaultCursor = \"default\";\n  this.plotArea = {\n    canvas: null,\n    ctx: null,\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    width: 0,\n    height: 0\n  };\n  this._dataInRenderedOrder = [];\n  this._container = typeof this._containerId === \"string\" ? document.getElementById(this._containerId) : this._containerId;\n\n  if (!this._container) {\n    if (window.console) window.console.log(\"CanvasJS Error: Chart Container with id \\\"\" + this._containerId + \"\\\" was not found\");\n    return;\n  }\n\n  this._container.innerHTML = \"\";\n  var width = 0;\n  var height = 0;\n  if (this._options.width) width = this.width;else width = this._container.clientWidth > 0 ? this._container.clientWidth : this.width;\n  if (this._options.height) height = this.height;else height = this._container.clientHeight > 0 ? this._container.clientHeight : this.height;\n  this.width = width;\n  this.height = height;\n  this.x1 = this.y1 = 0;\n  this.x2 = this.width;\n  this.y2 = this.height;\n  this._selectedColorSet = typeof colorSets[this.colorSet] !== \"undefined\" ? colorSets[this.colorSet] : colorSets[\"colorSet1\"];\n  this._canvasJSContainer = document.createElement(\"div\");\n\n  this._canvasJSContainer.setAttribute(\"class\", \"canvasjs-chart-container\");\n\n  this._canvasJSContainer.style.position = \"relative\";\n  this._canvasJSContainer.style.textAlign = \"left\";\n  this._canvasJSContainer.style.cursor = \"auto\";\n\n  if (!isCanvasSupported) {\n    this._canvasJSContainer.style.height = \"0px\"; //In IE6 toolTip doesn't show at proper position if not set.\n  }\n\n  this._container.appendChild(this._canvasJSContainer);\n\n  this.canvas = createCanvas(width, height);\n  this.canvas.style.position = \"absolute\";\n\n  if (this.canvas.getContext) {\n    //try {\n    //\tthis.canvas.style.background = this.backgroundColor;\n    //} catch (e) { }\n    this._canvasJSContainer.appendChild(this.canvas);\n\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.ctx.textBaseline = \"top\";\n    extendCtx(this.ctx);\n  } else return; //this.canvas.style.cursor = \"pointer\";\n\n\n  if (!isCanvasSupported) {\n    this.plotArea.canvas = createCanvas(width, height);\n    this.plotArea.canvas.style.position = \"absolute\";\n    this.plotArea.canvas.setAttribute(\"class\", \"plotAreaCanvas\");\n\n    this._canvasJSContainer.appendChild(this.plotArea.canvas);\n\n    this.plotArea.ctx = this.plotArea.canvas.getContext(\"2d\");\n  } else {\n    this.plotArea.ctx = this.ctx;\n  }\n\n  this.overlaidCanvas = createCanvas(width, height);\n  this.overlaidCanvas.style.position = \"absolute\";\n\n  this._canvasJSContainer.appendChild(this.overlaidCanvas);\n\n  this.overlaidCanvasCtx = this.overlaidCanvas.getContext(\"2d\");\n  this.overlaidCanvasCtx.textBaseline = \"top\";\n  this._eventManager = new EventManager(this);\n  addEvent(window, \"resize\", function () {\n    //this._container.addEventListener(\"DOMSubtreeModified\", function () {\n    if (_this._updateSize()) _this.render();\n  });\n  this._toolBar = document.createElement(\"div\");\n\n  this._toolBar.setAttribute(\"class\", \"canvasjs-chart-toolbar\");\n\n  this._toolBar.style.cssText = \"position: absolute; right: 1px; top: 1px;\";\n\n  this._canvasJSContainer.appendChild(this._toolBar);\n\n  this.bounds = {\n    x1: 0,\n    y1: 0,\n    x2: this.width,\n    y2: this.height\n  };\n  addEvent(this.overlaidCanvas, 'click', function (e) {\n    _this._mouseEventHandler(e);\n  });\n  addEvent(this.overlaidCanvas, 'mousemove', function (e) {\n    _this._mouseEventHandler(e);\n  });\n  addEvent(this.overlaidCanvas, 'mouseup', function (e) {\n    _this._mouseEventHandler(e);\n  });\n  addEvent(this.overlaidCanvas, 'mousedown', function (e) {\n    _this._mouseEventHandler(e);\n\n    hide(_this._dropdownMenu);\n  });\n  addEvent(this.overlaidCanvas, 'mouseout', function (e) {\n    _this._mouseEventHandler(e);\n  });\n  addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerDown\" : \"touchstart\", function (e) {\n    _this._touchEventHandler(e);\n  });\n  addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerMove\" : 'touchmove', function (e) {\n    _this._touchEventHandler(e);\n  });\n  addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerUp\" : 'touchend', function (e) {\n    _this._touchEventHandler(e);\n  });\n  addEvent(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerCancel\" : 'touchcancel', function (e) {\n    _this._touchEventHandler(e);\n  });\n\n  if (!this._creditLink) {\n    this._creditLink = document.createElement(\"a\");\n\n    this._creditLink.setAttribute(\"class\", \"canvasjs-chart-credit\");\n\n    this._creditLink.setAttribute(\"style\", \"outline:none;margin:0px;position:absolute;right:3px;top:\" + (this.height - 14) + \"px;color:dimgrey;text-decoration:none;font-size:10px;font-family:Lucida Grande, Lucida Sans Unicode, Arial, sans-serif\");\n\n    this._creditLink.setAttribute(\"tabIndex\", -1);\n\n    this._creditLink.setAttribute(\"target\", \"_blank\");\n  }\n\n  this._toolTip = new ToolTip(this, this._options.toolTip, this.theme);\n  this.data = null;\n  this.axisX = null;\n  this.axisY = null;\n  this.axisY2 = null;\n  this.sessionVariables = {\n    axisX: {},\n    axisY: {},\n    axisY2: {}\n  };\n}\n\nextend(Chart, CanvasJSObject); //Update Chart Properties\n\nChart.prototype._updateOptions = function () {\n  var _this = this;\n\n  this.updateOption(\"width\");\n  this.updateOption(\"height\");\n  this.updateOption(\"dataPointMaxWidth\");\n  this.updateOption(\"interactivityEnabled\");\n  this.updateOption(\"theme\");\n  if (this.updateOption(\"colorSet\")) this._selectedColorSet = typeof colorSets[this.colorSet] !== \"undefined\" ? colorSets[this.colorSet] : colorSets[\"colorSet1\"];\n  this.updateOption(\"backgroundColor\");\n  if (!this.backgroundColor) this.backgroundColor = \"rgba(0,0,0,0)\";\n  this.updateOption(\"culture\");\n  this._cultureInfo = new CultureInfo(this._options.culture);\n  this.updateOption(\"animationEnabled\");\n  this.animationEnabled = this.animationEnabled && isCanvasSupported;\n  this.updateOption(\"animationDuration\");\n  this.updateOption(\"rangeChanging\");\n  this.updateOption(\"rangeChanged\"); //Need to check this._options.zoomEnabled because this.zoomEnabled is used internally to keep track of state - and hence changes.\n\n  if (this._options.zoomEnabled) {\n    if (!this._zoomButton) {\n      hide(this._zoomButton = document.createElement(\"button\"));\n      setButtonState(this, this._zoomButton, \"pan\");\n\n      this._toolBar.appendChild(this._zoomButton);\n\n      addEvent(this._zoomButton, \"click\", function () {\n        if (_this.zoomEnabled) {\n          _this.zoomEnabled = false;\n          _this.panEnabled = true;\n          setButtonState(_this, _this._zoomButton, \"zoom\");\n        } else {\n          _this.zoomEnabled = true;\n          _this.panEnabled = false;\n          setButtonState(_this, _this._zoomButton, \"pan\");\n        }\n\n        _this.render();\n      });\n    }\n\n    if (!this._resetButton) {\n      hide(this._resetButton = document.createElement(\"button\"));\n      setButtonState(this, this._resetButton, \"reset\");\n\n      this._toolBar.appendChild(this._resetButton);\n\n      addEvent(this._resetButton, \"click\", function () {\n        _this._toolTip.hide();\n\n        if (_this.zoomEnabled || _this.panEnabled) {\n          _this.zoomEnabled = true;\n          _this.panEnabled = false;\n          setButtonState(_this, _this._zoomButton, \"pan\");\n          _this._defaultCursor = \"default\";\n          _this.overlaidCanvas.style.cursor = _this._defaultCursor;\n        } else {\n          _this.zoomEnabled = false;\n          _this.panEnabled = false;\n        } //Reset axisX\n\n\n        if (_this.sessionVariables.axisX) {\n          _this.sessionVariables.axisX.newViewportMinimum = null;\n          _this.sessionVariables.axisX.newViewportMaximum = null;\n        } //Reset axisY\n\n\n        if (_this.sessionVariables.axisY) {\n          _this.sessionVariables.axisY.newViewportMinimum = null;\n          _this.sessionVariables.axisY.newViewportMaximum = null;\n        } //Reset axisY2\n\n\n        if (_this.sessionVariables.axisY2) {\n          _this.sessionVariables.axisY2.newViewportMinimum = null;\n          _this.sessionVariables.axisY2.newViewportMaximum = null;\n        }\n\n        _this.resetOverlayedCanvas();\n\n        hide(_this._zoomButton, _this._resetButton);\n\n        _this._dispatchRangeEvent(\"rangeChanging\", \"reset\");\n\n        _this.render();\n\n        _this._dispatchRangeEvent(\"rangeChanged\", \"reset\");\n      });\n      this.overlaidCanvas.style.cursor = _this._defaultCursor;\n    }\n\n    if (!this.zoomEnabled && !this.panEnabled) {\n      if (!this._zoomButton) {\n        this.zoomEnabled = true;\n        this.panEnabled = false;\n      } else {\n        if (_this._zoomButton.getAttribute(\"state\") === _this._cultureInfo.zoomText) {\n          this.panEnabled = true;\n          this.zoomEnabled = false;\n        } else {\n          this.zoomEnabled = true;\n          this.panEnabled = false;\n        }\n\n        show(_this._zoomButton, _this._resetButton);\n      }\n    }\n  } else {\n    this.zoomEnabled = false;\n    this.panEnabled = false;\n  }\n\n  if (this._menuButton) {\n    if (this.exportEnabled) show(this._menuButton);else hide(this._menuButton);\n  } else if (this.exportEnabled && isCanvasSupported) {\n    this._menuButton = document.createElement(\"button\");\n    setButtonState(this, this._menuButton, \"menu\");\n\n    this._toolBar.appendChild(this._menuButton);\n\n    addEvent(this._menuButton, \"click\", function () {\n      if (_this._dropdownMenu.style.display === \"none\") {\n        if (_this._dropDownCloseTime && new Date().getTime() - _this._dropDownCloseTime.getTime() <= 500) return;\n        _this._dropdownMenu.style.display = \"block\";\n\n        _this._menuButton.blur();\n\n        _this._dropdownMenu.focus();\n      }\n    }, true);\n  }\n\n  if (!this._dropdownMenu && this.exportEnabled && isCanvasSupported) {\n    this._dropdownMenu = document.createElement(\"div\");\n\n    this._dropdownMenu.setAttribute(\"tabindex\", -1);\n\n    this._dropdownMenu.style.cssText = \"position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 1px;top: 25px;min-width: 120px;outline: 0;border: 1px solid silver;font-size: 14px;font-family: Calibri, Verdana, sans-serif;padding: 5px 0px 5px 0px;text-align: left;background-color: #fff;line-height: 20px;box-shadow: 2px 2px 10px #888888;\";\n    _this._dropdownMenu.style.display = \"none\";\n\n    this._toolBar.appendChild(this._dropdownMenu);\n\n    addEvent(this._dropdownMenu, \"blur\", function () {\n      hide(_this._dropdownMenu);\n      _this._dropDownCloseTime = new Date();\n    }, true);\n    var exportOption = document.createElement(\"div\");\n    exportOption.style.cssText = \"padding: 2px 15px 2px 10px\";\n    exportOption.innerHTML = this._cultureInfo.saveJPGText;\n\n    this._dropdownMenu.appendChild(exportOption);\n\n    addEvent(exportOption, \"mouseover\", function () {\n      this.style.backgroundColor = \"#EEEEEE\";\n    }, true);\n    addEvent(exportOption, \"mouseout\", function () {\n      this.style.backgroundColor = \"transparent\";\n    }, true);\n    addEvent(exportOption, \"click\", function () {\n      exportCanvas(_this.canvas, \"jpg\", _this.exportFileName);\n      hide(_this._dropdownMenu);\n    }, true);\n    var exportOption = document.createElement(\"div\");\n    exportOption.style.cssText = \"padding: 2px 15px 2px 10px\";\n    exportOption.innerHTML = this._cultureInfo.savePNGText;\n\n    this._dropdownMenu.appendChild(exportOption);\n\n    addEvent(exportOption, \"mouseover\", function () {\n      this.style.backgroundColor = \"#EEEEEE\";\n    }, true);\n    addEvent(exportOption, \"mouseout\", function () {\n      this.style.backgroundColor = \"transparent\";\n    }, true);\n    addEvent(exportOption, \"click\", function () {\n      exportCanvas(_this.canvas, \"png\", _this.exportFileName);\n      hide(_this._dropdownMenu);\n    }, true);\n  }\n\n  if (this._toolBar.style.display !== \"none\" && this._zoomButton) {\n    this.panEnabled ? setButtonState(_this, _this._zoomButton, \"zoom\") : setButtonState(_this, _this._zoomButton, \"pan\");\n    if (_this._resetButton.getAttribute(\"state\") !== _this._cultureInfo.resetText) setButtonState(_this, _this._resetButton, \"reset\");\n  }\n\n  if (typeof defaultOptions.Chart.creditHref === \"undefined\") {\n    this.creditHref = \"http://canvasjs.com/\";\n    this.creditText = \"CanvasJS.com\";\n  } else {\n    var creditTextChanged = this.updateOption(\"creditText\");\n    var creditHrefChanged = this.updateOption(\"creditHref\");\n  }\n\n  if (this.renderCount === 0 || creditTextChanged || creditHrefChanged) {\n    this._creditLink.setAttribute(\"href\", this.creditHref);\n\n    this._creditLink.innerHTML = this.creditText;\n  }\n\n  if (this.creditHref && this.creditText) {\n    if (!this._creditLink.parentElement) this._canvasJSContainer.appendChild(this._creditLink);\n  } else if (this._creditLink.parentElement) this._canvasJSContainer.removeChild(this._creditLink);\n\n  if (this._options.toolTip && this._toolTip._options !== this._options.toolTip) this._toolTip._options = this._options.toolTip;\n\n  for (var prop in this._toolTip._options) {\n    if (this._toolTip._options.hasOwnProperty(prop)) {\n      this._toolTip.updateOption(prop);\n    }\n  }\n};\n\nChart.prototype._updateSize = function () {\n  var width = 0;\n  var height = 0;\n  if (this._options.width) width = this.width;else this.width = width = this._container.clientWidth > 0 ? this._container.clientWidth : this.width;\n  if (this._options.height) height = this.height;else this.height = height = this._container.clientHeight > 0 ? this._container.clientHeight : this.height;\n\n  if (this.canvas.width !== width * devicePixelBackingStoreRatio || this.canvas.height !== height * devicePixelBackingStoreRatio) {\n    setCanvasSize(this.canvas, width, height);\n    setCanvasSize(this.overlaidCanvas, width, height);\n    setCanvasSize(this._eventManager.ghostCanvas, width, height);\n    return true;\n  }\n\n  return false;\n}; // initialize chart objects\n\n\nChart.prototype._initialize = function () {\n  ///<signature>\n  ///<summary>Initializes Chart objects/state. Creates DataSeries class instance for each DataSeries provided by ther user. Sets the Axis Type based on the user data</summary>\n  ///</signature>\n  //this.width = this.width;\n  if (!this._animator) this._animator = new Animator(this);else {\n    this._animator.cancelAllAnimations();\n  }\n  this.removeAllEventListeners();\n  this.disableToolTip = false;\n  this._axes = [];\n  this.pieDoughnutClickHandler = null; //this._touchCurrentCoordinates = null;\n\n  if (this.animationRequestId) this.cancelRequestAnimFrame.call(window, this.animationRequestId);\n\n  this._updateOptions();\n\n  this.animatedRender = isCanvasSupported && this.animationEnabled && this.renderCount === 0;\n\n  this._updateSize(); //this._selectedColorSet = colorSets[\"colorSet2\"];\n  //this.ctx.clearRect(0, 0, this.width, this.height);\n\n\n  this.clearCanvas();\n  this.ctx.beginPath();\n  this.axisX = null;\n  this.axisY = null;\n  this.axisY2 = null;\n  this._indexLabels = [];\n  this._dataInRenderedOrder = [];\n  this._events = [];\n  if (this._eventManager) this._eventManager.reset();\n  this.plotInfo = {\n    axisPlacement: null,\n    axisXValueType: null,\n    plotTypes: [] //array of plotType: {type:\"\", axisYType: \"primary\", dataSeriesIndexes:[]}\n\n  };\n  this.layoutManager = new LayoutManager(0, 0, this.width, this.height, 2);\n  if (this.plotArea.layoutManager) this.plotArea.layoutManager.reset();\n  this.data = [];\n  var dataSeriesIndex = 0;\n\n  for (var series = 0; series < this._options.data.length; series++) {\n    //for (series in this._options.data) {\n    dataSeriesIndex++;\n    if (!(!this._options.data[series].type || Chart._supportedChartTypes.indexOf(this._options.data[series].type) >= 0)) continue;\n    var dataSeries = new DataSeries(this, this._options.data[series], this.theme, dataSeriesIndex - 1, ++this._eventManager.lastObjectId);\n    if (dataSeries.name === null) dataSeries.name = \"DataSeries \" + dataSeriesIndex;\n\n    if (dataSeries.color === null) {\n      if (this._options.data.length > 1) {\n        dataSeries._colorSet = [this._selectedColorSet[dataSeries.index % this._selectedColorSet.length]];\n        dataSeries.color = this._selectedColorSet[dataSeries.index % this._selectedColorSet.length];\n      } else {\n        if (dataSeries.type === \"line\" || dataSeries.type === \"stepLine\" || dataSeries.type === \"spline\" || dataSeries.type === \"area\" || dataSeries.type === \"stepArea\" || dataSeries.type === \"splineArea\" || dataSeries.type === \"stackedArea\" || dataSeries.type === \"stackedArea100\" || dataSeries.type === \"rangeArea\" || dataSeries.type === \"rangeSplineArea\" || dataSeries.type === \"candlestick\" || dataSeries.type === \"ohlc\") {\n          dataSeries._colorSet = [this._selectedColorSet[0]];\n        } else dataSeries._colorSet = this._selectedColorSet;\n      }\n    } else {\n      dataSeries._colorSet = [dataSeries.color];\n    }\n\n    if (dataSeries.markerSize === null) {\n      if ((dataSeries.type === \"line\" || dataSeries.type === \"stepLine\" || dataSeries.type === \"spline\") && dataSeries.dataPoints && dataSeries.dataPoints.length < this.width / 16 || dataSeries.type === \"scatter\") {\n        //if (dataSeries.type === \"line\") {\n        dataSeries.markerSize = 8;\n      }\n    }\n\n    if ((dataSeries.type === \"bubble\" || dataSeries.type === \"scatter\") && dataSeries.dataPoints) {\n      dataSeries.dataPoints.sort(compareDataPointX);\n    } //if (dataSeries.markerBorderThickness === null && dataSeries.type === \"scatter\") {\n    //    dataSeries.markerBorderThickness = 2;\n    //}\n    //if (dataSeries.markerType === null) {\n    //    if (dataSeries.type === \"line\" & dataSeries.dataPoints.length < 500) {\n    //        dataSeries.markerType = \"circle\";\n    //    }\n    //}\n\n\n    this.data.push(dataSeries);\n    var seriesAxisPlacement = dataSeries.axisPlacement; //if (isDebugMode && window.console)\n    //    window.console.log(dataSeries.type);\n\n    var errorMessage;\n\n    if (seriesAxisPlacement === \"normal\") {\n      if (this.plotInfo.axisPlacement === \"xySwapped\") {\n        errorMessage = \"You cannot combine \\\"\" + dataSeries.type + \"\\\" with bar chart\";\n      } else if (this.plotInfo.axisPlacement === \"none\") {\n        errorMessage = \"You cannot combine \\\"\" + dataSeries.type + \"\\\" with pie chart\";\n      } else if (this.plotInfo.axisPlacement === null) this.plotInfo.axisPlacement = \"normal\";\n    } else if (seriesAxisPlacement === \"xySwapped\") {\n      if (this.plotInfo.axisPlacement === \"normal\") {\n        errorMessage = \"You cannot combine \\\"\" + dataSeries.type + \"\\\" with line, area, column or pie chart\";\n      } else if (this.plotInfo.axisPlacement === \"none\") {\n        errorMessage = \"You cannot combine \\\"\" + dataSeries.type + \"\\\" with pie chart\";\n      } else if (this.plotInfo.axisPlacement === null) this.plotInfo.axisPlacement = \"xySwapped\";\n    } else if (seriesAxisPlacement == \"none\") {\n      if (this.plotInfo.axisPlacement === \"normal\") {\n        errorMessage = \"You cannot combine \\\"\" + dataSeries.type + \"\\\" with line, area, column or bar chart\";\n      } else if (this.plotInfo.axisPlacement === \"xySwapped\") {\n        errorMessage = \"You cannot combine \\\"\" + dataSeries.type + \"\\\" with bar chart\";\n      } else if (this.plotInfo.axisPlacement === null) this.plotInfo.axisPlacement = \"none\";\n    }\n\n    if (errorMessage && window.console) {\n      window.console.log(errorMessage);\n      return;\n    }\n  } //if (isDebugMode && window.console) {\n  //    window.console.log(\"xMin: \" + this.plotInfo.viewPortXMin + \"; xMax: \" + this.plotInfo.viewPortXMax + \"; yMin: \" + this.plotInfo.yMin + \"; yMax: \" + this.plotInfo.yMax);\n  //}\n\n\n  this._objectsInitialized = true;\n}; //indexOf is not supported in IE8-\n\n\nChart._supportedChartTypes = addArrayIndexOf([\"line\", \"stepLine\", \"spline\", \"column\", \"area\", \"stepArea\", \"splineArea\", \"bar\", \"bubble\", \"scatter\", \"stackedColumn\", \"stackedColumn100\", \"stackedBar\", \"stackedBar100\", \"stackedArea\", \"stackedArea100\", \"candlestick\", \"ohlc\", \"rangeColumn\", \"rangeBar\", \"rangeArea\", \"rangeSplineArea\", \"pie\", \"doughnut\", \"funnel\"]);\n\nChart.prototype.render = function (options) {\n  if (options) this._options = options;\n\n  this._initialize();\n\n  var plotAreaElements = []; //Elements to be rendered inside the plotArea\n  //Create Primary and Secondary axis and assign them to the series\n\n  for (var i = 0; i < this.data.length; i++) {\n    if (this.plotInfo.axisPlacement === \"normal\" || this.plotInfo.axisPlacement === \"xySwapped\") {\n      if (!this.data[i].axisYType || this.data[i].axisYType === \"primary\") {\n        if (!this.axisY) {\n          if (this.plotInfo.axisPlacement === \"normal\") {\n            this._axes.push(this.axisY = new Axis(this, this._options.axisY, \"axisY\", \"left\"));\n          } else if (this.plotInfo.axisPlacement === \"xySwapped\") {\n            this._axes.push(this.axisY = new Axis(this, this._options.axisY, \"axisY\", \"bottom\"));\n          }\n        }\n\n        this.data[i].axisY = this.axisY;\n      } else if (this.data[i].axisYType === \"secondary\") {\n        if (!this.axisY2) {\n          if (this.plotInfo.axisPlacement === \"normal\") {\n            this._axes.push(this.axisY2 = new Axis(this, this._options.axisY2, \"axisY\", \"right\"));\n          } else if (this.plotInfo.axisPlacement === \"xySwapped\") {\n            this._axes.push(this.axisY2 = new Axis(this, this._options.axisY2, \"axisY\", \"top\"));\n          }\n        }\n\n        this.data[i].axisY = this.axisY2;\n      }\n\n      if (!this.axisX) {\n        if (this.plotInfo.axisPlacement === \"normal\") {\n          this._axes.push(this.axisX = new Axis(this, this._options.axisX, \"axisX\", \"bottom\"));\n        } else if (this.plotInfo.axisPlacement === \"xySwapped\") {\n          this._axes.push(this.axisX = new Axis(this, this._options.axisX, \"axisX\", \"left\"));\n        }\n      }\n\n      this.data[i].axisX = this.axisX;\n    }\n  } //If Both Primary and Secondary axis are present, disable gridlines for one of them unless the user has set value for both\n\n\n  if (this.axisY && this.axisY2) {\n    if (this.axisY.gridThickness > 0 && typeof this.axisY2._options.gridThickness === \"undefined\") this.axisY2.gridThickness = 0;else if (this.axisY2.gridThickness > 0 && typeof this.axisY._options.gridThickness === \"undefined\") this.axisY.gridThickness = 0;\n  } //Show toolBar when viewportMinimum/viewportMaximum are set\n\n\n  var showToolBar = false;\n\n  if (this._axes.length > 0 && (this.zoomEnabled || this.panEnabled)) {\n    for (var i = 0; i < this._axes.length; i++) {\n      if (this._axes[i].viewportMinimum !== null || this._axes[i].viewportMaximum !== null) {\n        showToolBar = true;\n        break;\n      }\n    }\n  }\n\n  if (showToolBar) {\n    show(this._zoomButton, this._resetButton);\n  } else {\n    hide(this._zoomButton, this._resetButton);\n  }\n\n  this._processData(); // Categorises the dataSeries and calculates min, max and other values\n\n\n  if (this._options.title) {\n    this._title = new Title(this, this._options.title);\n    if (!this._title.dockInsidePlotArea) this._title.render();else plotAreaElements.push(this._title);\n  }\n\n  if (this._options.subtitles) {\n    for (var i = 0; i < this._options.subtitles.length; i++) {\n      this.subtitles = [];\n      var subtitle = new Subtitle(this, this._options.subtitles[i]);\n      this.subtitles.push(subtitle);\n      if (!subtitle.dockInsidePlotArea) subtitle.render();else plotAreaElements.push(subtitle);\n    }\n  }\n\n  this.legend = new Legend(this, this._options.legend, this.theme);\n\n  for (var i = 0; i < this.data.length; i++) {\n    if (this.data[i].showInLegend || this.data[i].type === \"pie\" || this.data[i].type === \"doughnut\") {\n      this.legend.dataSeries.push(this.data[i]);\n    }\n  }\n\n  if (!this.legend.dockInsidePlotArea) this.legend.render();else plotAreaElements.push(this.legend); //TBI: Revisit and check if the functionality is enough.\n\n  if (this.plotInfo.axisPlacement === \"normal\" || this.plotInfo.axisPlacement === \"xySwapped\") {\n    //var freeSpace = this.layoutManager.getFreeSpace();\n    Axis.setLayoutAndRender(this.axisX, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());\n  } else if (this.plotInfo.axisPlacement === \"none\") {\n    //In case of charts with axis this method is called inside setLayoutAndRender\n    this.preparePlotArea();\n  } else {\n    return;\n  }\n\n  var index = 0;\n\n  for (index in plotAreaElements) {\n    if (plotAreaElements.hasOwnProperty(index)) plotAreaElements[index].render();\n  }\n\n  var animations = [];\n\n  if (this.animatedRender) {\n    var initialState = createCanvas(this.width, this.height);\n    var initialStateCtx = initialState.getContext(\"2d\");\n    initialStateCtx.drawImage(this.canvas, 0, 0, this.width, this.height);\n  }\n\n  for (var i = 0; i < this.plotInfo.plotTypes.length; i++) {\n    var plotType = this.plotInfo.plotTypes[i];\n\n    for (var j = 0; j < plotType.plotUnits.length; j++) {\n      var plotUnit = plotType.plotUnits[j];\n      var animationInfo = null;\n      plotUnit.targetCanvas = null; //In case chart updates before the animation is complete, previous canvases need to be removed\n\n      if (this.animatedRender) {\n        plotUnit.targetCanvas = createCanvas(this.width, this.height);\n        plotUnit.targetCanvasCtx = plotUnit.targetCanvas.getContext(\"2d\");\n      }\n\n      if (plotUnit.type === \"line\") animationInfo = this.renderLine(plotUnit);else if (plotUnit.type === \"stepLine\") animationInfo = this.renderStepLine(plotUnit);else if (plotUnit.type === \"spline\") animationInfo = this.renderSpline(plotUnit);else if (plotUnit.type === \"column\") animationInfo = this.renderColumn(plotUnit);else if (plotUnit.type === \"bar\") animationInfo = this.renderBar(plotUnit);else if (plotUnit.type === \"area\") animationInfo = this.renderArea(plotUnit);else if (plotUnit.type === \"stepArea\") animationInfo = this.renderStepArea(plotUnit);else if (plotUnit.type === \"splineArea\") animationInfo = this.renderSplineArea(plotUnit);else if (plotUnit.type === \"stackedColumn\") animationInfo = this.renderStackedColumn(plotUnit);else if (plotUnit.type === \"stackedColumn100\") animationInfo = this.renderStackedColumn100(plotUnit);else if (plotUnit.type === \"stackedBar\") animationInfo = this.renderStackedBar(plotUnit);else if (plotUnit.type === \"stackedBar100\") animationInfo = this.renderStackedBar100(plotUnit);else if (plotUnit.type === \"stackedArea\") animationInfo = this.renderStackedArea(plotUnit);else if (plotUnit.type === \"stackedArea100\") animationInfo = this.renderStackedArea100(plotUnit);else if (plotUnit.type === \"bubble\") animationInfo = animationInfo = this.renderBubble(plotUnit);else if (plotUnit.type === \"scatter\") animationInfo = this.renderScatter(plotUnit);else if (plotUnit.type === \"pie\") this.renderPie(plotUnit);else if (plotUnit.type === \"doughnut\") this.renderPie(plotUnit);else if (plotUnit.type === \"candlestick\") animationInfo = this.renderCandlestick(plotUnit);else if (plotUnit.type === \"ohlc\") animationInfo = this.renderCandlestick(plotUnit);else if (plotUnit.type === \"rangeColumn\") animationInfo = this.renderRangeColumn(plotUnit);else if (plotUnit.type === \"rangeBar\") animationInfo = this.renderRangeBar(plotUnit);else if (plotUnit.type === \"rangeArea\") animationInfo = this.renderRangeArea(plotUnit);else if (plotUnit.type === \"rangeSplineArea\") animationInfo = this.renderRangeSplineArea(plotUnit);\n\n      for (var k = 0; k < plotUnit.dataSeriesIndexes.length; k++) {\n        this._dataInRenderedOrder.push(this.data[plotUnit.dataSeriesIndexes[k]]);\n      }\n\n      if (this.animatedRender && animationInfo) animations.push(animationInfo);\n    }\n  }\n\n  if (this.animatedRender && this._indexLabels.length > 0) {\n    var indexLabelCanvas = createCanvas(this.width, this.height);\n    var indexLabelCanvasCtx = indexLabelCanvas.getContext(\"2d\");\n    animations.push(this.renderIndexLabels(indexLabelCanvasCtx));\n  }\n\n  var _this = this;\n\n  if (animations.length > 0) {\n    //var animationCount = 0;\n    _this.disableToolTip = true;\n\n    _this._animator.animate(200, _this.animationDuration, function (fractionComplete) {\n      //console.log(fractionComplete);\n      //animationCount++;\n      _this.ctx.clearRect(0, 0, _this.width, _this.height); //  _this.ctx.drawImage(initialState, 0, 0, _this.width * devicePixelBackingStoreRatio, _this.height * devicePixelBackingStoreRatio, 0, 0, _this.width, _this.height);\n\n\n      _this.ctx.drawImage(initialState, 0, 0, Math.floor(_this.width * devicePixelBackingStoreRatio), Math.floor(_this.height * devicePixelBackingStoreRatio), 0, 0, _this.width, _this.height);\n\n      for (var l = 0; l < animations.length; l++) {\n        animationInfo = animations[l];\n\n        if (fractionComplete < 1 && typeof animationInfo.startTimePercent !== \"undefined\") {\n          if (fractionComplete >= animationInfo.startTimePercent) {\n            //animationInfo.animationCallback(AnimationHelper.easing.linear(fractionComplete - animationInfo.startTimePercent, 0, 1, 1 - animationInfo.startTimePercent), animationInfo);\n            animationInfo.animationCallback(animationInfo.easingFunction(fractionComplete - animationInfo.startTimePercent, 0, 1, 1 - animationInfo.startTimePercent), animationInfo);\n          }\n        } else {\n          animationInfo.animationCallback(animationInfo.easingFunction(fractionComplete, 0, 1, 1), animationInfo);\n        }\n      }\n\n      _this.dispatchEvent(\"dataAnimationIterationEnd\", {\n        chart: _this\n      });\n    }, function () {\n      animations = [];\n      var count = 0; //Delete all render target canvases used for animation.\n\n      for (var i = 0; i < _this.plotInfo.plotTypes.length; i++) {\n        var plotType = _this.plotInfo.plotTypes[i];\n\n        for (var j = 0; j < plotType.plotUnits.length; j++) {\n          var plotUnit = plotType.plotUnits[j];\n          plotUnit.targetCanvas = null;\n        }\n      }\n\n      initialState = null;\n      _this.disableToolTip = false; //console.log(\"*********** Animation Complete - \" + animationCount + \" ***********\");\n    });\n  } else {\n    if (_this._indexLabels.length > 0) _this.renderIndexLabels();\n\n    _this.dispatchEvent(\"dataAnimationIterationEnd\", {\n      chart: _this\n    });\n  }\n\n  this.attachPlotAreaEventHandlers();\n\n  if (!this.zoomEnabled && !this.panEnabled && this._zoomButton && this._zoomButton.style.display !== \"none\") {\n    hide(this._zoomButton, this._resetButton);\n  }\n\n  this._toolTip._updateToolTip();\n\n  this.renderCount++; //if (window.console) {\n  //    window.console.log(new Date().getTime() - dt);\n  //}\n\n  if (isDebugMode) {\n    var _this = this;\n\n    setTimeout(function () {\n      var ghostCanvasCopy = document.getElementById(\"ghostCanvasCopy\");\n\n      if (ghostCanvasCopy) {\n        //console.log(ghostCanvasCopy.clientWidth);\n        setCanvasSize(ghostCanvasCopy, _this.width, _this.height);\n        var ghostCanvasCopyCtx = ghostCanvasCopy.getContext(\"2d\"); //ghostCanvasCopyCtx.scale(1, 1);\n        //var imageData = this._eventManager.ghostCtx.getImageData(0, 0, this._container.clientWidth, this._container.clientHeight);\n        //this._eventManager.ghostCtx.drawImage(this._eventManager.ghostCanvas, 0, 0);\n        //this.ctx.drawImage(this._eventManager.ghostCanvas, 0, 0);\n\n        ghostCanvasCopyCtx.drawImage(_this._eventManager.ghostCanvas, 0, 0); //_this._canvasJSContainer.appendChild(_this._eventManager.ghostCanvas);\n        //_this.overlaidCanvasCtx.drawImage(_this._eventManager.ghostCanvas, 0, 0);\n      }\n    }, 2000);\n  }\n};\n\nChart.prototype.attachPlotAreaEventHandlers = function () {\n  //this._toolBar.style.display = \"inline\";\n  this.attachEvent({\n    context: this,\n    chart: this,\n    mousedown: this._plotAreaMouseDown,\n    mouseup: this._plotAreaMouseUp,\n    mousemove: this._plotAreaMouseMove,\n    cursor: this.zoomEnabled ? \"col-resize\" : \"move\",\n    cursor: this.panEnabled ? \"move\" : \"default\",\n    capture: true,\n    bounds: this.plotArea\n  });\n};\n\nChart.prototype.categoriseDataSeries = function () {\n  var dataSeries = \"\";\n\n  for (var i = 0; i < this.data.length; i++) {\n    dataSeries = this.data[i];\n    if (!dataSeries.dataPoints || dataSeries.dataPoints.length === 0 || !dataSeries.visible) continue;\n\n    if (Chart._supportedChartTypes.indexOf(dataSeries.type) >= 0) {\n      var plotType = null;\n      var plotTypeExists = false;\n      var plotUnit = null;\n      var plotUnitExists = false;\n\n      for (var j = 0; j < this.plotInfo.plotTypes.length; j++) {\n        if (this.plotInfo.plotTypes[j].type === dataSeries.type) {\n          plotTypeExists = true;\n          var plotType = this.plotInfo.plotTypes[j];\n          break;\n        }\n      }\n\n      if (!plotTypeExists) {\n        plotType = {\n          type: dataSeries.type,\n          totalDataSeries: 0,\n          plotUnits: []\n        };\n        this.plotInfo.plotTypes.push(plotType);\n      }\n\n      for (var j = 0; j < plotType.plotUnits.length; j++) {\n        if (plotType.plotUnits[j].axisYType === dataSeries.axisYType) {\n          plotUnitExists = true;\n          var plotUnit = plotType.plotUnits[j];\n          break;\n        }\n      }\n\n      if (!plotUnitExists) {\n        plotUnit = {\n          type: dataSeries.type,\n          previousDataSeriesCount: 0,\n          //to be set next\n          index: plotType.plotUnits.length,\n          plotType: plotType,\n          axisYType: dataSeries.axisYType,\n          axisY: dataSeries.axisYType === \"primary\" ? this.axisY : this.axisY2,\n          axisX: this.axisX,\n          dataSeriesIndexes: [],\n          //index of dataSeries\n          yTotals: []\n        };\n        plotType.plotUnits.push(plotUnit);\n      }\n\n      plotType.totalDataSeries++;\n      plotUnit.dataSeriesIndexes.push(i);\n      dataSeries.plotUnit = plotUnit;\n    }\n  }\n\n  for (var i = 0; i < this.plotInfo.plotTypes.length; i++) {\n    var plotType = this.plotInfo.plotTypes[i];\n    var previousDataSeriesCount = 0;\n\n    for (var j = 0; j < plotType.plotUnits.length; j++) {\n      plotType.plotUnits[j].previousDataSeriesCount = previousDataSeriesCount;\n      previousDataSeriesCount += plotType.plotUnits[j].dataSeriesIndexes.length;\n    }\n  }\n};\n\nChart.prototype.assignIdToDataPoints = function () {\n  for (var i = 0; i < this.data.length; i++) {\n    var dataSeries = this.data[i];\n    if (!dataSeries.dataPoints) continue;\n    var length = dataSeries.dataPoints.length;\n\n    for (var j = 0; j < length; j++) {\n      dataSeries.dataPointIds[j] = ++this._eventManager.lastObjectId;\n    }\n  }\n};\n\nChart.prototype._processData = function () {\n  this.assignIdToDataPoints();\n  this.categoriseDataSeries();\n\n  for (var i = 0; i < this.plotInfo.plotTypes.length; i++) {\n    var plotType = this.plotInfo.plotTypes[i];\n\n    for (var j = 0; j < plotType.plotUnits.length; j++) {\n      var plotUnit = plotType.plotUnits[j];\n      if (plotUnit.type === \"line\" || plotUnit.type === \"stepLine\" || plotUnit.type === \"spline\" || plotUnit.type === \"column\" || plotUnit.type === \"area\" || plotUnit.type === \"stepArea\" || plotUnit.type === \"splineArea\" || plotUnit.type === \"bar\" || plotUnit.type === \"bubble\" || plotUnit.type === \"scatter\") this._processMultiseriesPlotUnit(plotUnit);else if (plotUnit.type === \"stackedColumn\" || plotUnit.type === \"stackedBar\" || plotUnit.type === \"stackedArea\") this._processStackedPlotUnit(plotUnit);else if (plotUnit.type === \"stackedColumn100\" || plotUnit.type === \"stackedBar100\" || plotUnit.type === \"stackedArea100\") this._processStacked100PlotUnit(plotUnit);else if (plotUnit.type === \"candlestick\" || plotUnit.type === \"ohlc\" || plotUnit.type === \"rangeColumn\" || plotUnit.type === \"rangeBar\" || plotUnit.type === \"rangeArea\" || plotUnit.type === \"rangeSplineArea\") this._processMultiYPlotUnit(plotUnit);\n    }\n  }\n};\n\nChart.prototype._processMultiseriesPlotUnit = function (plotUnit) {\n  if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length < 1) return;\n  var axisYDataInfo = plotUnit.axisY.dataInfo;\n  var axisXDataInfo = plotUnit.axisX.dataInfo;\n  var dataPointX, dataPointY;\n  var isDateTime = false;\n\n  for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {\n    var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];\n    var i = 0;\n    var isFirstDPInViewPort = false;\n    var isLastDPInViewPort = false;\n\n    if (dataSeries.axisPlacement === \"normal\" || dataSeries.axisPlacement === \"xySwapped\") {\n      var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -Infinity;\n      var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : Infinity;\n    }\n\n    if (dataSeries.dataPoints[i].x && dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === \"dateTime\") {\n      isDateTime = true;\n    }\n\n    for (i = 0; i < dataSeries.dataPoints.length; i++) {\n      if (typeof dataSeries.dataPoints[i].x === \"undefined\") {\n        dataSeries.dataPoints[i].x = i;\n      }\n\n      if (dataSeries.dataPoints[i].x.getTime) {\n        isDateTime = true;\n        dataPointX = dataSeries.dataPoints[i].x.getTime(); //dataPointX is used so that getTime is called only once in case of dateTime values\n      } else dataPointX = dataSeries.dataPoints[i].x;\n\n      dataPointY = dataSeries.dataPoints[i].y;\n      if (dataPointX < axisXDataInfo.min) axisXDataInfo.min = dataPointX;\n      if (dataPointX > axisXDataInfo.max) axisXDataInfo.max = dataPointX;\n      if (dataPointY < axisYDataInfo.min) axisYDataInfo.min = dataPointY;\n      if (dataPointY > axisYDataInfo.max) axisYDataInfo.max = dataPointY;\n\n      if (i > 0) {\n        var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;\n        xDiff < 0 && (xDiff = xDiff * -1); //If Condition shortcut\n\n        if (axisXDataInfo.minDiff > xDiff && xDiff !== 0) {\n          axisXDataInfo.minDiff = xDiff;\n        }\n\n        if (dataPointY !== null && dataSeries.dataPoints[i - 1].y !== null) {\n          var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;\n          yDiff < 0 && (yDiff = yDiff * -1); //If Condition shortcut\n\n          if (axisYDataInfo.minDiff > yDiff && yDiff !== 0) {\n            axisYDataInfo.minDiff = yDiff;\n          }\n        }\n      } // This section makes sure that partially visible dataPoints are included in the begining\n\n\n      if (dataPointX < plotAreaXMin && !isFirstDPInViewPort) {\n        continue;\n      } else if (!isFirstDPInViewPort) {\n        isFirstDPInViewPort = true;\n\n        if (i > 0) {\n          i -= 2;\n          continue;\n        }\n      } // This section makes sure that partially visible dataPoints are included at the end\n\n\n      if (dataPointX > plotAreaXMax && !isLastDPInViewPort) {\n        isLastDPInViewPort = true;\n      } else if (dataPointX > plotAreaXMax && isLastDPInViewPort) {\n        continue;\n      }\n\n      if (dataSeries.dataPoints[i].label) plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;\n      if (dataPointX < axisXDataInfo.viewPortMin) axisXDataInfo.viewPortMin = dataPointX;\n      if (dataPointX > axisXDataInfo.viewPortMax) axisXDataInfo.viewPortMax = dataPointX;\n      if (dataPointY === null) continue;\n      if (dataPointY < axisYDataInfo.viewPortMin) axisYDataInfo.viewPortMin = dataPointY;\n      if (dataPointY > axisYDataInfo.viewPortMax) axisYDataInfo.viewPortMax = dataPointY;\n    }\n\n    this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? \"dateTime\" : \"number\";\n  } //this.dataPoints.sort(compareDataPointX);\n  //this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });\n\n};\n\nChart.prototype._processStackedPlotUnit = function (plotUnit) {\n  if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length < 1) return;\n  var axisYDataInfo = plotUnit.axisY.dataInfo;\n  var axisXDataInfo = plotUnit.axisX.dataInfo;\n  var dataPointX, dataPointY;\n  var isDateTime = false;\n  var dataPointYPositiveSums = [];\n  var dataPointYNegativeSums = [];\n\n  for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {\n    var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];\n    var i = 0;\n    var isFirstDPInViewPort = false;\n    var isLastDPInViewPort = false;\n\n    if (dataSeries.axisPlacement === \"normal\" || dataSeries.axisPlacement === \"xySwapped\") {\n      var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -Infinity;\n      var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : Infinity;\n    }\n\n    if (dataSeries.dataPoints[i].x && dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === \"dateTime\") {\n      isDateTime = true;\n    }\n\n    for (i = 0; i < dataSeries.dataPoints.length; i++) {\n      // Requird when no x values are provided\n      if (typeof dataSeries.dataPoints[i].x === \"undefined\") {\n        dataSeries.dataPoints[i].x = i;\n      }\n\n      if (dataSeries.dataPoints[i].x.getTime) {\n        isDateTime = true;\n        dataPointX = dataSeries.dataPoints[i].x.getTime(); //dataPointX is used so that getTime is called only once in case of dateTime values\n      } else dataPointX = dataSeries.dataPoints[i].x;\n\n      dataPointY = dataSeries.dataPoints[i].y;\n      if (dataPointX < axisXDataInfo.min) axisXDataInfo.min = dataPointX;\n      if (dataPointX > axisXDataInfo.max) axisXDataInfo.max = dataPointX;\n\n      if (i > 0) {\n        var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;\n        xDiff < 0 && (xDiff = xDiff * -1); //If Condition shortcut\n\n        if (axisXDataInfo.minDiff > xDiff && xDiff !== 0) {\n          axisXDataInfo.minDiff = xDiff;\n        }\n\n        if (dataPointY !== null && dataSeries.dataPoints[i - 1].y !== null) {\n          var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;\n          yDiff < 0 && (yDiff = yDiff * -1); //If Condition shortcut\n\n          if (axisYDataInfo.minDiff > yDiff && yDiff !== 0) {\n            axisYDataInfo.minDiff = yDiff;\n          }\n        }\n      } // This section makes sure that partially visible dataPoints are included in the begining\n\n\n      if (dataPointX < plotAreaXMin && !isFirstDPInViewPort) {\n        continue;\n      } else if (!isFirstDPInViewPort) {\n        isFirstDPInViewPort = true;\n\n        if (i > 0) {\n          i -= 2;\n          continue;\n        }\n      } // This section makes sure that partially visible dataPoints are included at the end\n\n\n      if (dataPointX > plotAreaXMax && !isLastDPInViewPort) {\n        isLastDPInViewPort = true;\n      } else if (dataPointX > plotAreaXMax && isLastDPInViewPort) {\n        continue;\n      }\n\n      if (dataSeries.dataPoints[i].label) plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;\n      if (dataPointX < axisXDataInfo.viewPortMin) axisXDataInfo.viewPortMin = dataPointX;\n      if (dataPointX > axisXDataInfo.viewPortMax) axisXDataInfo.viewPortMax = dataPointX;\n      if (dataPointY === null) continue;\n      plotUnit.yTotals[dataPointX] = (!plotUnit.yTotals[dataPointX] ? 0 : plotUnit.yTotals[dataPointX]) + Math.abs(dataPointY);\n\n      if (dataPointY >= 0) {\n        if (dataPointYPositiveSums[dataPointX]) dataPointYPositiveSums[dataPointX] += dataPointY;else dataPointYPositiveSums[dataPointX] = dataPointY;\n      } else {\n        if (dataPointYNegativeSums[dataPointX]) dataPointYNegativeSums[dataPointX] += dataPointY;else dataPointYNegativeSums[dataPointX] = dataPointY;\n      }\n    }\n\n    this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? \"dateTime\" : \"number\";\n  }\n\n  for (i in dataPointYPositiveSums) {\n    if (dataPointYPositiveSums.hasOwnProperty(i)) {\n      if (isNaN(i)) {\n        continue;\n      }\n\n      var ySum = dataPointYPositiveSums[i];\n      if (ySum < axisYDataInfo.min) axisYDataInfo.min = ySum;\n      if (ySum > axisYDataInfo.max) axisYDataInfo.max = ySum;\n      if (i < axisXDataInfo.viewPortMin || i > axisXDataInfo.viewPortMax) continue;\n      if (ySum < axisYDataInfo.viewPortMin) axisYDataInfo.viewPortMin = ySum;\n      if (ySum > axisYDataInfo.viewPortMax) axisYDataInfo.viewPortMax = ySum;\n    }\n  }\n\n  for (i in dataPointYNegativeSums) {\n    if (dataPointYNegativeSums.hasOwnProperty(i)) {\n      if (isNaN(i)) {\n        continue;\n      }\n\n      var ySum = dataPointYNegativeSums[i];\n      if (ySum < axisYDataInfo.min) axisYDataInfo.min = ySum;\n      if (ySum > axisYDataInfo.max) axisYDataInfo.max = ySum;\n      if (i < axisXDataInfo.viewPortMin || i > axisXDataInfo.viewPortMax) continue;\n      if (ySum < axisYDataInfo.viewPortMin) axisYDataInfo.viewPortMin = ySum;\n      if (ySum > axisYDataInfo.viewPortMax) axisYDataInfo.viewPortMax = ySum;\n    }\n  } //this.dataPoints.sort(compareDataPointX);\n  //this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });\n  //window.console.log(\"viewPortYMin: \" + plotInfo.viewPortYMin + \"; viewPortYMax: \" + plotInfo.viewPortYMax);\n\n};\n\nChart.prototype._processStacked100PlotUnit = function (plotUnit) {\n  if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length < 1) return;\n  var axisYDataInfo = plotUnit.axisY.dataInfo;\n  var axisXDataInfo = plotUnit.axisX.dataInfo;\n  var dataPointX, dataPointY;\n  var isDateTime = false;\n  var containsPositiveY = false;\n  var containsNegativeY = false;\n  var dataPointYSums = [];\n\n  for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {\n    var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];\n    var i = 0;\n    var isFirstDPInViewPort = false;\n    var isLastDPInViewPort = false;\n\n    if (dataSeries.axisPlacement === \"normal\" || dataSeries.axisPlacement === \"xySwapped\") {\n      var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -Infinity;\n      var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : Infinity;\n    }\n\n    if (dataSeries.dataPoints[i].x && dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === \"dateTime\") {\n      isDateTime = true;\n    }\n\n    for (i = 0; i < dataSeries.dataPoints.length; i++) {\n      // Requird when no x values are provided\n      if (typeof dataSeries.dataPoints[i].x === \"undefined\") {\n        dataSeries.dataPoints[i].x = i;\n      }\n\n      if (dataSeries.dataPoints[i].x.getTime) {\n        isDateTime = true;\n        dataPointX = dataSeries.dataPoints[i].x.getTime(); //dataPointX is used so that getTime is called only once in case of dateTime values\n      } else dataPointX = dataSeries.dataPoints[i].x;\n\n      dataPointY = dataSeries.dataPoints[i].y;\n      if (dataPointX < axisXDataInfo.min) axisXDataInfo.min = dataPointX;\n      if (dataPointX > axisXDataInfo.max) axisXDataInfo.max = dataPointX;\n\n      if (i > 0) {\n        var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;\n        xDiff < 0 && (xDiff = xDiff * -1); //If Condition shortcut\n\n        if (axisXDataInfo.minDiff > xDiff && xDiff !== 0) {\n          axisXDataInfo.minDiff = xDiff;\n        }\n\n        if (dataPointY !== null && dataSeries.dataPoints[i - 1].y !== null) {\n          var yDiff = dataPointY - dataSeries.dataPoints[i - 1].y;\n          yDiff < 0 && (yDiff = yDiff * -1); //If Condition shortcut\n\n          if (axisYDataInfo.minDiff > yDiff && yDiff !== 0) {\n            axisYDataInfo.minDiff = yDiff;\n          }\n        }\n      } // This section makes sure that partially visible dataPoints are included in the begining\n\n\n      if (dataPointX < plotAreaXMin && !isFirstDPInViewPort) {\n        continue;\n      } else if (!isFirstDPInViewPort) {\n        isFirstDPInViewPort = true;\n\n        if (i > 0) {\n          i -= 2;\n          continue;\n        }\n      } // This section makes sure that partially visible dataPoints are included at the end\n\n\n      if (dataPointX > plotAreaXMax && !isLastDPInViewPort) {\n        isLastDPInViewPort = true;\n      } else if (dataPointX > plotAreaXMax && isLastDPInViewPort) {\n        continue;\n      }\n\n      if (dataSeries.dataPoints[i].label) plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;\n      if (dataPointX < axisXDataInfo.viewPortMin) axisXDataInfo.viewPortMin = dataPointX;\n      if (dataPointX > axisXDataInfo.viewPortMax) axisXDataInfo.viewPortMax = dataPointX;\n      if (dataPointY === null) continue;\n      plotUnit.yTotals[dataPointX] = (!plotUnit.yTotals[dataPointX] ? 0 : plotUnit.yTotals[dataPointX]) + Math.abs(dataPointY);\n\n      if (dataPointY >= 0) {\n        containsPositiveY = true;\n      } else {\n        containsNegativeY = true;\n      }\n\n      if (dataPointYSums[dataPointX]) dataPointYSums[dataPointX] += Math.abs(dataPointY);else dataPointYSums[dataPointX] = Math.abs(dataPointY);\n    }\n\n    this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? \"dateTime\" : \"number\";\n  }\n\n  if (containsPositiveY && !containsNegativeY) {\n    axisYDataInfo.max = 99;\n    axisYDataInfo.min = 1;\n  } else if (containsPositiveY && containsNegativeY) {\n    axisYDataInfo.max = 99;\n    axisYDataInfo.min = -99;\n  } else if (!containsPositiveY && containsNegativeY) {\n    axisYDataInfo.max = -1;\n    axisYDataInfo.min = -99;\n  }\n\n  axisYDataInfo.viewPortMin = axisYDataInfo.min;\n  axisYDataInfo.viewPortMax = axisYDataInfo.max;\n  plotUnit.dataPointYSums = dataPointYSums; //this.dataPoints.sort(compareDataPointX);\n  //this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });\n  //window.console.log(\"viewPortYMin: \" + plotInfo.viewPortYMin + \"; viewPortYMax: \" + plotInfo.viewPortYMax);\n};\n\nChart.prototype._processMultiYPlotUnit = function (plotUnit) {\n  if (!plotUnit.dataSeriesIndexes || plotUnit.dataSeriesIndexes.length < 1) return;\n  var axisYDataInfo = plotUnit.axisY.dataInfo;\n  var axisXDataInfo = plotUnit.axisX.dataInfo;\n  var dataPointX, dataPointY, dataPointYMin, dataPointYMax;\n  var isDateTime = false;\n\n  for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {\n    var dataSeries = this.data[plotUnit.dataSeriesIndexes[j]];\n    var i = 0;\n    var isFirstDPInViewPort = false;\n    var isLastDPInViewPort = false;\n\n    if (dataSeries.axisPlacement === \"normal\" || dataSeries.axisPlacement === \"xySwapped\") {\n      var plotAreaXMin = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -Infinity;\n      var plotAreaXMax = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : Infinity;\n    }\n\n    if (dataSeries.dataPoints[i].x && dataSeries.dataPoints[i].x.getTime || dataSeries.xValueType === \"dateTime\") {\n      isDateTime = true;\n    }\n\n    for (i = 0; i < dataSeries.dataPoints.length; i++) {\n      if (typeof dataSeries.dataPoints[i].x === \"undefined\") {\n        dataSeries.dataPoints[i].x = i;\n      }\n\n      if (dataSeries.dataPoints[i].x.getTime) {\n        isDateTime = true;\n        dataPointX = dataSeries.dataPoints[i].x.getTime(); //dataPointX is used so that getTime is called only once in case of dateTime values\n      } else dataPointX = dataSeries.dataPoints[i].x;\n\n      dataPointY = dataSeries.dataPoints[i].y;\n\n      if (dataPointY && dataPointY.length) {\n        dataPointYMin = Math.min.apply(null, dataPointY);\n        dataPointYMax = Math.max.apply(null, dataPointY);\n      }\n\n      if (dataPointX < axisXDataInfo.min) axisXDataInfo.min = dataPointX;\n      if (dataPointX > axisXDataInfo.max) axisXDataInfo.max = dataPointX;\n      if (dataPointYMin < axisYDataInfo.min) axisYDataInfo.min = dataPointYMin;\n      if (dataPointYMax > axisYDataInfo.max) axisYDataInfo.max = dataPointYMax;\n\n      if (i > 0) {\n        var xDiff = dataPointX - dataSeries.dataPoints[i - 1].x;\n        xDiff < 0 && (xDiff = xDiff * -1); //If Condition shortcut\n\n        if (axisXDataInfo.minDiff > xDiff && xDiff !== 0) {\n          axisXDataInfo.minDiff = xDiff;\n        }\n\n        if (dataPointY[0] !== null && dataSeries.dataPoints[i - 1].y[0] !== null) {\n          var yDiff = dataPointY[0] - dataSeries.dataPoints[i - 1].y[0];\n          yDiff < 0 && (yDiff = yDiff * -1); //If Condition shortcut\n\n          if (axisYDataInfo.minDiff > yDiff && yDiff !== 0) {\n            axisYDataInfo.minDiff = yDiff;\n          }\n        }\n      } // This section makes sure that partially visible dataPoints are included in the begining\n\n\n      if (dataPointX < plotAreaXMin && !isFirstDPInViewPort) {\n        continue;\n      } else if (!isFirstDPInViewPort) {\n        isFirstDPInViewPort = true;\n\n        if (i > 0) {\n          i -= 2;\n          continue;\n        }\n      } // This section makes sure that partially visible dataPoints are included at the end\n\n\n      if (dataPointX > plotAreaXMax && !isLastDPInViewPort) {\n        isLastDPInViewPort = true;\n      } else if (dataPointX > plotAreaXMax && isLastDPInViewPort) {\n        continue;\n      }\n\n      if (dataSeries.dataPoints[i].label) plotUnit.axisX.labels[dataPointX] = dataSeries.dataPoints[i].label;\n      if (dataPointX < axisXDataInfo.viewPortMin) axisXDataInfo.viewPortMin = dataPointX;\n      if (dataPointX > axisXDataInfo.viewPortMax) axisXDataInfo.viewPortMax = dataPointX;\n      if (dataPointY === null) continue;\n      if (dataPointYMin < axisYDataInfo.viewPortMin) axisYDataInfo.viewPortMin = dataPointYMin;\n      if (dataPointYMax > axisYDataInfo.viewPortMax) axisYDataInfo.viewPortMax = dataPointYMax;\n    }\n\n    this.plotInfo.axisXValueType = dataSeries.xValueType = isDateTime ? \"dateTime\" : \"number\";\n  } //this.dataPoints.sort(compareDataPointX);\n  //this.dataPoints.sort(function (dataPoint1, dataPoint2) { return dataPoint1.x - dataPoint2.x; });\n\n}; //getClosest returns objects nearby and hence shouldn't be used for events like click, mouseover, mousemove, etc which require object that is exactly under the mouse.\n\n\nChart.prototype.getDataPointAtXY = function (mouseX, mouseY, getClosest) {\n  getClosest = getClosest || false;\n  var results = [];\n\n  for (var i = this._dataInRenderedOrder.length - 1; i >= 0; i--) {\n    var dataSeries = this._dataInRenderedOrder[i];\n    var result = null;\n    result = dataSeries.getDataPointAtXY(mouseX, mouseY, getClosest);\n    if (result) results.push(result);\n  }\n\n  var closestResult = null;\n  var onlyLineAreaTypes = false;\n\n  for (var m = 0; m < results.length; m++) {\n    if (results[m].dataSeries.type === \"line\" || results[m].dataSeries.type === \"stepLine\" || results[m].dataSeries.type === \"area\" || results[m].dataSeries.type === \"stepArea\") {\n      var markerSize = getProperty(\"markerSize\", results[m].dataPoint, results[m].dataSeries) || 8;\n\n      if (results[m].distance <= markerSize / 2) {\n        onlyLineAreaTypes = true;\n        break;\n      }\n    }\n  }\n\n  for (m = 0; m < results.length; m++) {\n    if (onlyLineAreaTypes && results[m].dataSeries.type !== \"line\" && results[m].dataSeries.type !== \"stepLine\" && results[m].dataSeries.type !== \"area\" && results[m].dataSeries.type !== \"stepArea\") continue;\n\n    if (!closestResult) {\n      closestResult = results[m];\n    } else if (results[m].distance <= closestResult.distance) {\n      closestResult = results[m];\n    }\n  }\n\n  return closestResult;\n};\n\nChart.prototype.getObjectAtXY = function (mouseX, mouseY, getClosest) {\n  getClosest = getClosest || false;\n  var id = null;\n  var dataPointInfo = this.getDataPointAtXY(mouseX, mouseY, getClosest);\n\n  if (dataPointInfo) {\n    id = dataPointInfo.dataSeries.dataPointIds[dataPointInfo.dataPointIndex];\n  } else if (isCanvasSupported) {\n    //IE9+\n    id = getObjectId(mouseX, mouseY, this._eventManager.ghostCtx);\n  } else {\n    for (var i = 0; i < this.legend.items.length; i++) {\n      var item = this.legend.items[i];\n\n      if (mouseX >= item.x1 && mouseX <= item.x2 && mouseY >= item.y1 && mouseY <= item.y2) {\n        id = item.id;\n      }\n    }\n  }\n\n  return id;\n}; /// <summary>Calculates Font Size based on standardSize and Chart Size</summary>\n/// <param name=\"standardSize\" type=\"Number\">Standard font size for a Chart with min(width,height) = 400px</param>\n/// <returns type=\"Number\">The area.</returns>\n\n\nChart.prototype.getAutoFontSize = function (standardSize, width, height) {\n  width = width || this.width;\n  height = height || this.height;\n  var fontSizeScaleFactor = standardSize / 400;\n  return Math.round(Math.min(this.width, this.height) * fontSizeScaleFactor);\n}; //#region Events\n\n\nChart.prototype.resetOverlayedCanvas = function () {\n  //var width = this.overlaidCanvas.width;\n  //this.overlaidCanvas.width = 0;\n  //this.overlaidCanvas.width = width;\n  this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);\n};\n\nChart.prototype.clearCanvas = function () {\n  this.ctx.clearRect(0, 0, this.width, this.height);\n\n  if (this.backgroundColor) {\n    this.ctx.fillStyle = this.backgroundColor;\n    this.ctx.fillRect(0, 0, this.width, this.height);\n  }\n};\n\nChart.prototype.attachEvent = function (param) {\n  this._events.push(param);\n};\n\nChart.prototype._touchEventHandler = function (ev) {\n  if (!ev.changedTouches || !this.interactivityEnabled) return;\n  var mouseEvents = [];\n  var touches = ev.changedTouches;\n  var first = touches ? touches[0] : ev;\n  var touchCurrentCoordinates = null; //window.console.log(touches.length);\n\n  switch (ev.type) {\n    case \"touchstart\":\n    case \"MSPointerDown\":\n      mouseEvents = [\"mousemove\", \"mousedown\"];\n      this._lastTouchData = getMouseCoordinates(first);\n      this._lastTouchData.time = new Date();\n      break;\n\n    case \"touchmove\":\n    case \"MSPointerMove\":\n      mouseEvents = [\"mousemove\"];\n      break;\n\n    case \"touchend\":\n    case \"MSPointerUp\":\n      mouseEvents = this._lastTouchEventType === \"touchstart\" || this._lastTouchEventType === \"MSPointerDown\" ? [\"mouseup\", \"click\"] : [\"mouseup\"];\n      break;\n\n    default:\n      return;\n  }\n\n  if (touches && touches.length > 1) return;\n  touchCurrentCoordinates = getMouseCoordinates(first);\n  touchCurrentCoordinates.time = new Date();\n\n  try {\n    var dy = touchCurrentCoordinates.y - this._lastTouchData.y;\n    var dx = touchCurrentCoordinates.x - this._lastTouchData.x;\n    var dt = touchCurrentCoordinates.time - this._lastTouchData.time;\n\n    if (Math.abs(dy) > 15 && (!!this._lastTouchData.scroll || dt < 200)) {\n      //this._lastTouchData.y = touchCurrentCoordinates.y;\n      this._lastTouchData.scroll = true;\n      var win = window.parent || window;\n      if (win && win.scrollBy) win.scrollBy(0, -dy);\n    }\n  } catch (e) {}\n\n  ;\n  this._lastTouchEventType = ev.type;\n\n  if (!!this._lastTouchData.scroll && this.zoomEnabled) {\n    if (this.isDrag) this.resetOverlayedCanvas();\n    this.isDrag = false;\n    return;\n  }\n\n  for (var i = 0; i < mouseEvents.length; i++) {\n    var type = mouseEvents[i];\n    var simulatedEvent = document.createEvent(\"MouseEvent\");\n    simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0, null);\n    first.target.dispatchEvent(simulatedEvent);\n\n    if (ev.preventManipulation) {\n      //alert(\"preventManipulation\");\n      ev.preventManipulation();\n    }\n\n    if (ev.preventDefault) {\n      //alert(\"preventDefault\");\n      ev.preventDefault();\n    }\n  }\n};\n\nChart.prototype._dispatchRangeEvent = function (eventName, triggerSource) {\n  var eventParameter = {};\n  eventParameter.chart = this._publicChartReference;\n  eventParameter.type = eventName;\n  eventParameter.trigger = triggerSource;\n  var axes = [];\n  if (this.axisX) axes.push(\"axisX\");\n  if (this.axisY) axes.push(\"axisY\");\n  if (this.axisY2) axes.push(\"axisY2\");\n\n  for (var i = 0; i < axes.length; i++) {\n    eventParameter[axes[i]] = {\n      viewportMinimum: this[axes[i]].sessionVariables.newViewportMinimum,\n      viewportMaximum: this[axes[i]].sessionVariables.newViewportMaximum\n    };\n  }\n\n  this.dispatchEvent(eventName, eventParameter, this._publicChartReference);\n};\n\nChart.prototype._mouseEventHandler = function (ev) {\n  if (!this.interactivityEnabled) return;\n\n  if (this._ignoreNextEvent) {\n    this._ignoreNextEvent = false;\n    return;\n  } // stop panning and zooming so we can draw\n\n\n  if (ev.preventManipulation) {\n    //alert(\"preventManipulation\");\n    ev.preventManipulation();\n  } // we are handling this event\n\n\n  if (ev.preventDefault) {\n    //alert(\"preventDefault\");\n    ev.preventDefault();\n  } //IE8- uses srcElement instead of target. So instead of checking this condition everytime, its better to create a reference called target.\n\n\n  if (typeof ev.target === \"undefined\" && ev.srcElement) ev.target = ev.srcElement; //console.log(ev.type);\n\n  var xy = getMouseCoordinates(ev);\n  var type = ev.type;\n  var eventParam;\n  var rightclick;\n  if (!ev) var e = window.event;\n  if (ev.which) rightclick = ev.which == 3;else if (ev.button) rightclick = ev.button == 2; //window.console.log(type + \" --> x: \" + xy.x + \"; y:\" + xy.y);\n  //if (type === \"mouseout\") {\n  //    this._toolTip.hide();\n  //}\n\n  if (isDebugMode && window.console) {\n    window.console.log(type + \" --> x: \" + xy.x + \"; y:\" + xy.y);\n    if (rightclick) window.console.log(ev.which);\n    if (type === \"mouseup\") window.console.log(\"mouseup\");\n  }\n\n  if (rightclick) return; //if (this.plotInfo.axisPlacement === \"xySwapped\") {\n  //    //var temp = xy.x;\n  //    //xy.x = xy.y;\n  //    //xy.y = temp;\n  //    xy = {x: xy.y, y: xy.x};\n  //}\n\n  if (Chart.capturedEventParam) {\n    eventParam = Chart.capturedEventParam;\n\n    if (type === \"mouseup\") {\n      Chart.capturedEventParam = null;\n      if (eventParam.chart.overlaidCanvas.releaseCapture) eventParam.chart.overlaidCanvas.releaseCapture();else document.body.removeEventListener(\"mouseup\", eventParam.chart._mouseEventHandler, false);\n    }\n\n    if (eventParam.hasOwnProperty(type)) eventParam[type].call(eventParam.context, xy.x, xy.y);\n  } else if (this._events) {\n    for (var i = 0; i < this._events.length; i++) {\n      if (!this._events[i].hasOwnProperty(type)) continue;\n      eventParam = this._events[i];\n      var bounds = eventParam.bounds;\n\n      if (xy.x >= bounds.x1 && xy.x <= bounds.x2 && xy.y >= bounds.y1 && xy.y <= bounds.y2) {\n        eventParam[type].call(eventParam.context, xy.x, xy.y);\n\n        if (type === \"mousedown\" && eventParam.capture === true) {\n          Chart.capturedEventParam = eventParam;\n          if (this.overlaidCanvas.setCapture) this.overlaidCanvas.setCapture();else {\n            document.body.addEventListener(\"mouseup\", this._mouseEventHandler, false); //addEvent(document.body, \"mouseup\", this._mouseEventHandler);\n          }\n        } else if (type === \"mouseup\") {\n          if (eventParam.chart.overlaidCanvas.releaseCapture) eventParam.chart.overlaidCanvas.releaseCapture();else document.body.removeEventListener(\"mouseup\", this._mouseEventHandler, false);\n        }\n\n        break;\n      } else eventParam = null;\n    }\n\n    if (eventParam && eventParam.cursor) {\n      ev.target.style.cursor = eventParam.cursor;\n    } else ev.target.style.cursor = this._defaultCursor; //eventParam =\n\n  }\n\n  if (this._toolTip && this._toolTip.enabled) {\n    var plotArea = this.plotArea;\n    if (xy.x < plotArea.x1 || xy.x > plotArea.x2 || xy.y < plotArea.y1 || xy.y > plotArea.y2) this._toolTip.hide();\n  }\n\n  if ((!this.isDrag || !this.zoomEnabled) && this._eventManager) {\n    this._eventManager.mouseEventHandler(ev); //this._updateToolTip(ev.x, ev.y);\n\n  } //if (this._toolTip.enabled)\n  //    this._toolTip.mouseMoveHandler(ev.x, ev.y);\n\n};\n\nChart.prototype._plotAreaMouseDown = function (x, y) {\n  this.isDrag = true;\n\n  if (this.plotInfo.axisPlacement !== \"none\") {\n    this.dragStartPoint = {\n      x: x,\n      y: y\n    };\n  } else {\n    this.dragStartPoint = {\n      x: x,\n      y: y\n    };\n  }\n};\n\nChart.prototype._plotAreaMouseUp = function (x, y) {\n  if (this.plotInfo.axisPlacement === \"normal\" || this.plotInfo.axisPlacement === \"xySwapped\") {\n    if (this.isDrag) {\n      var dragDelta = 0,\n          dragDeltaPY = y - this.dragStartPoint.y,\n          dragDeltaPX = x - this.dragStartPoint.x,\n          zoomPX = this.zoomType.indexOf(\"x\") >= 0,\n          //Whether to zoom horizontally\n      zoomPY = this.zoomType.indexOf(\"y\") >= 0,\n          //Whether to zoom vertically\n      reRender = false;\n      this.resetOverlayedCanvas();\n\n      if (this.plotInfo.axisPlacement === \"xySwapped\") {\n        var temp = zoomPY;\n        zoomPY = zoomPX;\n        zoomPX = temp;\n      }\n\n      if (this.panEnabled || this.zoomEnabled) {\n        if (this.panEnabled) {\n          var overflow = 0;\n\n          for (var i = 0; i < this._axes.length; i++) {\n            var axis = this._axes[i];\n\n            if (axis.viewportMinimum < axis.minimum) {\n              overflow = axis.minimum - axis.viewportMinimum;\n              axis.sessionVariables.newViewportMinimum = axis.viewportMinimum + overflow;\n              axis.sessionVariables.newViewportMaximum = axis.viewportMaximum + overflow;\n              reRender = true;\n            } else if (axis.viewportMaximum > axis.maximum) {\n              overflow = axis.viewportMaximum - axis.maximum;\n              axis.sessionVariables.newViewportMinimum = axis.viewportMinimum - overflow;\n              axis.sessionVariables.newViewportMaximum = axis.viewportMaximum - overflow;\n              reRender = true;\n            }\n          }\n        } else if ((!zoomPX || Math.abs(dragDeltaPX) > 2) && (!zoomPY || Math.abs(dragDeltaPY) > 2) && this.zoomEnabled) {\n          if (!this.dragStartPoint) return;\n          var selectedRegion = {\n            x1: zoomPX ? this.dragStartPoint.x : this.plotArea.x1,\n            y1: zoomPY ? this.dragStartPoint.y : this.plotArea.y1,\n            x2: zoomPX ? x : this.plotArea.x2,\n            y2: zoomPY ? y : this.plotArea.y2\n          };\n\n          if (Math.abs(selectedRegion.x1 - selectedRegion.x2) > 2 && Math.abs(selectedRegion.y1 - selectedRegion.y2) > 2) {\n            if (this._zoomPanToSelectedRegion(selectedRegion.x1, selectedRegion.y1, selectedRegion.x2, selectedRegion.y2)) {\n              reRender = true;\n            }\n          }\n        }\n\n        if (reRender) {\n          this._ignoreNextEvent = true; //Required so that click event doesn't fire after zooming into a section of the chart.\n\n          this._dispatchRangeEvent(\"rangeChanging\", \"zoom\");\n\n          this.render();\n\n          this._dispatchRangeEvent(\"rangeChanged\", \"zoom\");\n\n          if (reRender && this.zoomEnabled && this._zoomButton.style.display === \"none\") {\n            show(this._zoomButton, this._resetButton);\n            setButtonState(this, this._zoomButton, \"pan\");\n            setButtonState(this, this._resetButton, \"reset\");\n          }\n        }\n      }\n    }\n  }\n\n  this.isDrag = false;\n};\n\nChart.prototype._plotAreaMouseMove = function (x, y) {\n  if (this.isDrag && this.plotInfo.axisPlacement !== \"none\") {\n    var dragDeltaPX = 0,\n        dragDeltaPY = 0,\n        alpha = null,\n        selectedRegion = null,\n        zoomPX = this.zoomType.indexOf(\"x\") >= 0,\n        //Whether to zoom horizontally\n    zoomPY = this.zoomType.indexOf(\"y\") >= 0,\n        //Whether to zoom vertically\n    _this = this;\n\n    if (this.plotInfo.axisPlacement === \"xySwapped\") {\n      var temp = zoomPY;\n      zoomPY = zoomPX;\n      zoomPX = temp;\n    }\n\n    dragDeltaPX = this.dragStartPoint.x - x;\n    dragDeltaPY = this.dragStartPoint.y - y;\n\n    if (Math.abs(dragDeltaPX) > 2 && Math.abs(dragDeltaPX) < 8 && (this.panEnabled || this.zoomEnabled)) {\n      this._toolTip.hide();\n    } else if (!this.panEnabled && !this.zoomEnabled) {\n      this._toolTip.mouseMoveHandler(x, y);\n    }\n\n    if ((!zoomPX || Math.abs(dragDeltaPX) > 2 || !zoomPY || Math.abs(dragDeltaPY) > 2) && (this.panEnabled || this.zoomEnabled)) {\n      if (this.panEnabled) {\n        selectedRegion = {\n          x1: zoomPX ? this.plotArea.x1 + dragDeltaPX : this.plotArea.x1,\n          y1: zoomPY ? this.plotArea.y1 + dragDeltaPY : this.plotArea.y1,\n          x2: zoomPX ? this.plotArea.x2 + dragDeltaPX : this.plotArea.x2,\n          y2: zoomPY ? this.plotArea.y2 + dragDeltaPY : this.plotArea.y2\n        };\n\n        if (this._zoomPanToSelectedRegion(selectedRegion.x1, selectedRegion.y1, selectedRegion.x2, selectedRegion.y2, true)) {\n          this._dispatchRangeEvent(\"rangeChanging\", \"pan\");\n\n          this.render();\n\n          this._dispatchRangeEvent(\"rangeChanged\", \"pan\");\n\n          this.dragStartPoint.x = x;\n          this.dragStartPoint.y = y; //clearTimeout(this._panTimerId);\n          //this._panTimerId = setTimeout(function () {\n          //\t_this._dispatchRangeEvent(\"rangeChanging\", \"pan\");\n          //\t_this.render();\n          //\t_this._dispatchRangeEvent(\"rangeChanged\", \"pan\");\n          //}, 0);\n        }\n      } else if (this.zoomEnabled) {\n        this.resetOverlayedCanvas();\n        alpha = this.overlaidCanvasCtx.globalAlpha;\n        this.overlaidCanvasCtx.globalAlpha = .7;\n        this.overlaidCanvasCtx.fillStyle = \"#A0ABB8\";\n        var rect = {\n          x1: zoomPX ? this.dragStartPoint.x : this.plotArea.x1,\n          y1: zoomPY ? this.dragStartPoint.y : this.plotArea.y1,\n          x2: zoomPX ? x - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1,\n          y2: zoomPY ? y - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1\n        };\n        this.overlaidCanvasCtx.fillRect(rect.x1, rect.y1, rect.x2, rect.y2);\n        this.overlaidCanvasCtx.globalAlpha = alpha;\n      }\n    }\n  } else this._toolTip.mouseMoveHandler(x, y);\n}; //#endregion Events\n//Sets the viewport range of Axis based on the given rect bounds (pixels). Also limits the zooming/panning based on axis bounds. Returns a boolean to indicate whether it was succesful or not based on the selected region.\n\n\nChart.prototype._zoomPanToSelectedRegion = function (px1, py1, px2, py2, keepAxisIndependent) {\n  keepAxisIndependent = keepAxisIndependent || false;\n  var zoomPX = this.zoomType.indexOf(\"x\") >= 0,\n      //Whether to zoom horizontally\n  zoomPY = this.zoomType.indexOf(\"y\") >= 0,\n      //Whether to zoom vertically\n  validRegion = false;\n  var axes = [],\n      axesWithValidRange = [];\n  if (this.axisX && zoomPX) axes.push(this.axisX);\n  if (this.axisY && zoomPY) axes.push(this.axisY);\n  if (this.axisY2 && zoomPY) axes.push(this.axisY2);\n  var params = [];\n\n  for (var i = 0; i < axes.length; i++) {\n    var axis = axes[i]; //var range = Math.abs(axis.viewportMaximum - axis.viewportMinimum);\n\n    var val1 = axis.convertPixelToValue({\n      x: px1,\n      y: py1\n    });\n    var val2 = axis.convertPixelToValue({\n      x: px2,\n      y: py2\n    });\n\n    if (val1 > val2) {\n      var temp = val2;\n      val2 = val1;\n      val1 = temp;\n    }\n\n    if (isFinite(axis.dataInfo.minDiff)) {\n      if (!(Math.abs(val2 - val1) < 3 * Math.abs(axis.dataInfo.minDiff) || val1 < axis.minimum || val2 > axis.maximum)) {\n        axesWithValidRange.push(axis);\n        params.push({\n          val1: val1,\n          val2: val2\n        });\n        validRegion = true;\n      } else if (!keepAxisIndependent) {\n        validRegion = false;\n        break;\n      }\n    }\n  }\n\n  if (validRegion) {\n    for (var i = 0; i < axesWithValidRange.length; i++) {\n      var axis = axesWithValidRange[i];\n      var param = params[i];\n      axis.setViewPortRange(param.val1, param.val2);\n    }\n  }\n\n  return validRegion;\n};\n\nChart.prototype.preparePlotArea = function () {\n  var plotArea = this.plotArea;\n  var yAxis = this.axisY ? this.axisY : this.axisY2;\n\n  if (!isCanvasSupported && (plotArea.x1 > 0 || plotArea.y1 > 0)) {\n    plotArea.ctx.translate(plotArea.x1, plotArea.y1);\n  }\n\n  if (this.axisX && yAxis) {\n    plotArea.x1 = this.axisX.lineCoordinates.x1 < this.axisX.lineCoordinates.x2 ? this.axisX.lineCoordinates.x1 : yAxis.lineCoordinates.x1;\n    plotArea.y1 = this.axisX.lineCoordinates.y1 < yAxis.lineCoordinates.y1 ? this.axisX.lineCoordinates.y1 : yAxis.lineCoordinates.y1;\n    plotArea.x2 = this.axisX.lineCoordinates.x2 > yAxis.lineCoordinates.x2 ? this.axisX.lineCoordinates.x2 : yAxis.lineCoordinates.x2;\n    plotArea.y2 = this.axisX.lineCoordinates.y2 > this.axisX.lineCoordinates.y1 ? this.axisX.lineCoordinates.y2 : yAxis.lineCoordinates.y2;\n    plotArea.width = plotArea.x2 - plotArea.x1;\n    plotArea.height = plotArea.y2 - plotArea.y1; //plotArea = { x1: x1, y1: y1, x2: x2, y2: y2, width: x2 - x1, height: y2 - y1 };\n  } else {\n    //ToDo: @sunil\n    var freeSpace = this.layoutManager.getFreeSpace();\n    plotArea.x1 = freeSpace.x1;\n    plotArea.x2 = freeSpace.x2;\n    plotArea.y1 = freeSpace.y1;\n    plotArea.y2 = freeSpace.y2;\n    plotArea.width = freeSpace.width;\n    plotArea.height = freeSpace.height;\n  }\n\n  if (!isCanvasSupported) {\n    plotArea.canvas.width = plotArea.width;\n    plotArea.canvas.height = plotArea.height;\n    plotArea.canvas.style.left = plotArea.x1 + \"px\";\n    plotArea.canvas.style.top = plotArea.y1 + \"px\";\n\n    if (plotArea.x1 > 0 || plotArea.y1 > 0) {\n      plotArea.ctx.translate(-plotArea.x1, -plotArea.y1);\n    }\n  }\n\n  plotArea.layoutManager = new LayoutManager(plotArea.x1, plotArea.y1, plotArea.x2, plotArea.y2, 2);\n};\n\nChart.prototype.getPixelCoordinatesOnPlotArea = function (x, y) {\n  return {\n    x: this.axisX.getPixelCoordinatesOnAxis(x).x,\n    y: this.axisY.getPixelCoordinatesOnAxis(y).y //return { x: 5, y: 10 };\n\n  };\n}; //#region Render Methods\n\n\nChart.prototype.renderIndexLabels = function (targetCtx) {\n  var ctx = targetCtx || this.plotArea.ctx;\n  var plotArea = this.plotArea;\n  var mid = 0;\n  var yMinLimit = 0;\n  var yMaxLimit = 0;\n  var xMinLimit = 0;\n  var xMaxLimit = 0;\n  var marginX = 0,\n      marginY = 0; // Margin between label and dataPoint / PlotArea\n\n  var offSetX = 0,\n      offSetY = 0; // Distance to offSet textBlock (top) from dataPoint inorder to position it\n\n  var visibleWidth = 0;\n  var visibleHeight = 0;\n\n  for (var i = 0; i < this._indexLabels.length; i++) {\n    var indexLabel = this._indexLabels[i];\n    var chartTypeLower = indexLabel.chartType.toLowerCase();\n    var x, y, angle;\n    var fontColor = getProperty(\"indexLabelFontColor\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var fontSize = getProperty(\"indexLabelFontSize\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var fontFamily = getProperty(\"indexLabelFontFamily\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var fontStyle = getProperty(\"indexLabelFontStyle\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var fontWeight = getProperty(\"indexLabelFontWeight\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var backgroundColor = getProperty(\"indexLabelBackgroundColor\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var maxWidth = getProperty(\"indexLabelMaxWidth\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var indexLabelWrap = getProperty(\"indexLabelWrap\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var percentAndTotal = {\n      percent: null,\n      total: null\n    };\n    var formatterParameter = null;\n    if (indexLabel.dataSeries.type.indexOf(\"stacked\") >= 0 || indexLabel.dataSeries.type === \"pie\" || indexLabel.dataSeries.type === \"doughnut\") percentAndTotal = this.getPercentAndTotal(indexLabel.dataSeries, indexLabel.dataPoint);\n    if (indexLabel.dataSeries.indexLabelFormatter || indexLabel.dataPoint.indexLabelFormatter) formatterParameter = {\n      chart: this._options,\n      dataSeries: indexLabel.dataSeries,\n      dataPoint: indexLabel.dataPoint,\n      index: indexLabel.indexKeyword,\n      total: percentAndTotal.total,\n      percent: percentAndTotal.percent\n    };\n    var indexLabelText = indexLabel.dataPoint.indexLabelFormatter ? indexLabel.dataPoint.indexLabelFormatter(formatterParameter) : indexLabel.dataPoint.indexLabel ? this.replaceKeywordsWithValue(indexLabel.dataPoint.indexLabel, indexLabel.dataPoint, indexLabel.dataSeries, null, indexLabel.indexKeyword) : indexLabel.dataSeries.indexLabelFormatter ? indexLabel.dataSeries.indexLabelFormatter(formatterParameter) : indexLabel.dataSeries.indexLabel ? this.replaceKeywordsWithValue(indexLabel.dataSeries.indexLabel, indexLabel.dataPoint, indexLabel.dataSeries, null, indexLabel.indexKeyword) : null;\n    if (indexLabelText === null || indexLabelText === \"\") continue;\n    var placement = getProperty(\"indexLabelPlacement\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var orientation = getProperty(\"indexLabelOrientation\", indexLabel.dataPoint, indexLabel.dataSeries);\n    var angle = 0;\n    var direction = indexLabel.direction; // +1 for above the point and -1 for below the point\n\n    var axisX = indexLabel.dataSeries.axisX;\n    var axisY = indexLabel.dataSeries.axisY;\n    var textBlock = new TextBlock(ctx, {\n      x: 0,\n      y: 0,\n      maxWidth: maxWidth ? maxWidth : this.width * .5,\n      maxHeight: indexLabelWrap ? fontSize * 5 : fontSize * 1.5,\n      angle: orientation === \"horizontal\" ? 0 : -90,\n      text: indexLabelText,\n      padding: 0,\n      backgroundColor: backgroundColor,\n      horizontalAlign: \"left\",\n      //left, center, right\n      fontSize: fontSize,\n      //in pixels\n      fontFamily: fontFamily,\n      fontWeight: fontWeight,\n      //normal, bold, bolder, lighter,\n      fontColor: fontColor,\n      fontStyle: fontStyle,\n      // normal, italic, oblique\n      textBaseline: \"top\"\n    });\n    var textSize = textBlock.measureText(); //if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum || indexLabel.dataPoint.y < axisY.viewportMinimum || indexLabel.dataPoint.y > axisY.viewportMaximum)\n    //\tcontinue;\n\n    if (chartTypeLower.indexOf(\"line\") >= 0 || chartTypeLower.indexOf(\"area\") >= 0 || chartTypeLower.indexOf(\"bubble\") >= 0 || chartTypeLower.indexOf(\"scatter\") >= 0) {\n      if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum || indexLabel.dataPoint.y < axisY.viewportMinimum || indexLabel.dataPoint.y > axisY.viewportMaximum) continue;\n    } else {\n      if (indexLabel.dataPoint.x < axisX.viewportMinimum || indexLabel.dataPoint.x > axisX.viewportMaximum) continue;\n    }\n\n    marginY = 2;\n    marginX = 2;\n\n    if (orientation === \"horizontal\") {\n      visibleWidth = textBlock.width;\n      visibleHeight = textBlock.height;\n    } else {\n      visibleHeight = textBlock.width;\n      visibleWidth = textBlock.height;\n    }\n\n    if (this.plotInfo.axisPlacement === \"normal\") {\n      if (chartTypeLower.indexOf(\"line\") >= 0 || chartTypeLower.indexOf(\"area\") >= 0) {\n        placement = \"auto\";\n        marginY = 4;\n      } else if (chartTypeLower.indexOf(\"stacked\") >= 0) {\n        if (placement === \"auto\") placement = \"inside\";\n      } else if (chartTypeLower === \"bubble\" || chartTypeLower === \"scatter\") {\n        placement = \"inside\";\n      }\n\n      x = indexLabel.point.x - visibleWidth / 2;\n\n      if (placement !== \"inside\") {\n        //outside or auto\n        yMinLimit = plotArea.y1;\n        yMaxLimit = plotArea.y2;\n\n        if (direction > 0) {\n          y = indexLabel.point.y - visibleHeight - marginY;\n\n          if (y < yMinLimit) {\n            if (placement === \"auto\") {\n              y = Math.max(indexLabel.point.y, yMinLimit) + marginY;\n            } else {\n              y = yMinLimit + marginY;\n            }\n          }\n        } else {\n          y = indexLabel.point.y + marginY;\n\n          if (y > yMaxLimit - visibleHeight - marginY) {\n            if (placement === \"auto\") {\n              y = Math.min(indexLabel.point.y, yMaxLimit) - visibleHeight - marginY;\n            } else {\n              y = yMaxLimit - visibleHeight - marginY;\n            }\n          }\n        }\n      } else {\n        yMinLimit = Math.max(indexLabel.bounds.y1, plotArea.y1);\n        yMaxLimit = Math.min(indexLabel.bounds.y2, plotArea.y2);\n\n        if (chartTypeLower.indexOf(\"range\") >= 0) {\n          if (direction > 0) mid = Math.max(indexLabel.bounds.y1, plotArea.y1) + visibleHeight / 2 + marginY;else mid = Math.min(indexLabel.bounds.y2, plotArea.y2) - visibleHeight / 2 - marginY;\n        } else mid = (Math.max(indexLabel.bounds.y1, plotArea.y1) + Math.min(indexLabel.bounds.y2, plotArea.y2)) / 2;\n\n        if (direction > 0) {\n          y = Math.max(indexLabel.point.y, mid) - visibleHeight / 2;\n\n          if (y < yMinLimit && (chartTypeLower === \"bubble\" || chartTypeLower === \"scatter\")) {\n            y = Math.max(indexLabel.point.y - visibleHeight - marginY, plotArea.y1 + marginY);\n          }\n        } else {\n          y = Math.min(indexLabel.point.y, mid) - visibleHeight / 2;\n\n          if (y > yMaxLimit - visibleHeight - marginY && (chartTypeLower === \"bubble\" || chartTypeLower === \"scatter\")) {\n            y = Math.min(indexLabel.point.y + marginY, plotArea.y2 - visibleHeight - marginY);\n          }\n        } // Make Sure that it does not overlap the axis line\n\n\n        y = Math.min(y, yMaxLimit - visibleHeight);\n      }\n    } else {\n      if (chartTypeLower.indexOf(\"line\") >= 0 || chartTypeLower.indexOf(\"area\") >= 0 || chartTypeLower.indexOf(\"scatter\") >= 0) {\n        placement = \"auto\";\n        marginX = 4;\n      } else if (chartTypeLower.indexOf(\"stacked\") >= 0) {\n        if (placement === \"auto\") placement = \"inside\";\n      } else if (chartTypeLower === \"bubble\") {\n        placement = \"inside\";\n      }\n\n      y = indexLabel.point.y - visibleHeight / 2;\n\n      if (placement !== \"inside\") {\n        //outside or auto\n        xMinLimit = plotArea.x1;\n        xMaxLimit = plotArea.x2;\n\n        if (direction < 0) {\n          x = indexLabel.point.x - visibleWidth - marginX;\n\n          if (x < xMinLimit) {\n            if (placement === \"auto\") {\n              x = Math.max(indexLabel.point.x, xMinLimit) + marginX;\n            } else {\n              x = xMinLimit + marginX;\n            }\n          }\n        } else {\n          x = indexLabel.point.x + marginX;\n\n          if (x > xMaxLimit - visibleWidth - marginX) {\n            if (placement === \"auto\") {\n              x = Math.min(indexLabel.point.x, xMaxLimit) - visibleWidth - marginX;\n            } else {\n              x = xMaxLimit - visibleWidth - marginX;\n            }\n          }\n        }\n      } else {\n        xMinLimit = Math.max(indexLabel.bounds.x1, plotArea.x1);\n        xMaxLimit = Math.min(indexLabel.bounds.x2, plotArea.x2);\n\n        if (chartTypeLower.indexOf(\"range\") >= 0) {\n          if (direction < 0) mid = Math.max(indexLabel.bounds.x1, plotArea.x1) + visibleWidth / 2 + marginX;else mid = Math.min(indexLabel.bounds.x2, plotArea.x2) - visibleWidth / 2 - marginX;\n        } else var mid = (Math.max(indexLabel.bounds.x1, plotArea.x1) + Math.min(indexLabel.bounds.x2, plotArea.x2)) / 2;\n\n        if (direction < 0) {\n          x = Math.max(indexLabel.point.x, mid) - visibleWidth / 2; //if (y < xMinLimit) {\n          //\ty = Math.max(indexLabel.point.y - visibleHeight - marginY, plotArea.y1 + marginY);\n          //}\n        } else {\n          x = Math.min(indexLabel.point.x, mid) - visibleWidth / 2; //if (y > xMaxLimit - visibleHeight - marginY) {\n          //\ty = Math.min(indexLabel.point.y + marginY, plotArea.y2 - visibleHeight - marginY);\n          //}\n        } // Make Sure that it does not overlap the axis line\n\n\n        x = Math.max(x, xMinLimit);\n      }\n    }\n\n    if (orientation === \"vertical\") {\n      y += visibleHeight;\n    }\n\n    textBlock.x = x;\n    textBlock.y = y; //console.log(textBlock.text + \": \" + textBlock.x + \"; \" + textBlock.y);\n\n    textBlock.render(true);\n  } //source and dest would be same when animation is not enabled\n\n\n  var animationInfo = {\n    source: ctx,\n    dest: this.plotArea.ctx,\n    animationCallback: AnimationHelper.fadeInAnimation,\n    easingFunction: AnimationHelper.easing.easeInQuad,\n    animationBase: 0,\n    startTimePercent: .7\n  };\n  return animationInfo;\n};\n\nChart.prototype.renderLine = function (plotUnit) {\n  var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;\n  var totalDataSeries = plotUnit.dataSeriesIndexes.length;\n  if (totalDataSeries <= 0) return;\n  var ghostCtx = this._eventManager.ghostCtx; //var ghostCtx = this.overlaidCanvasCtx;\n\n  ctx.save();\n  var plotArea = this.plotArea;\n  ctx.beginPath();\n  ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);\n  ctx.clip();\n  var markers = [];\n\n  for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {\n    var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];\n    var dataSeries = this.data[dataSeriesIndex];\n    ctx.lineWidth = dataSeries.lineThickness;\n    var dataPoints = dataSeries.dataPoints;\n\n    if (ctx.setLineDash) {\n      ctx.setLineDash(getLineDashArray(dataSeries.lineDashType, dataSeries.lineThickness));\n    }\n\n    var seriesId = dataSeries.id;\n    this._eventManager.objectMap[seriesId] = {\n      objectType: \"dataSeries\",\n      dataSeriesIndex: dataSeriesIndex\n    };\n    var hexColor = intToHexColorString(seriesId);\n    ghostCtx.strokeStyle = hexColor; //ghostCtx.lineWidth = dataSeries.lineThickness;\n\n    ghostCtx.lineWidth = dataSeries.lineThickness > 0 ? Math.max(dataSeries.lineThickness, 4) : 0;\n    var colorSet = dataSeries._colorSet;\n    var color = colorSet[0];\n    ctx.strokeStyle = color;\n    var isFirstDataPointInPlotArea = true;\n    var i = 0,\n        x,\n        y;\n    var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.\n    //if (!dataSeries._options.markerSize && dataSeries.dataPoints.length < 1000)\n    //    dataSeries.markerSize = 8;\n\n    ctx.beginPath();\n\n    if (dataPoints.length > 0) {\n      //var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);\n      //dataSeries.noDataPointsInPlotArea = 0\n      var prevDataNull = false;\n\n      for (i = 0; i < dataPoints.length; i++) {\n        dataPointX = dataPoints[i].x.getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;\n        if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) continue; //if (!isFinite(dataPoints[i].y))\n        //    continue;\n\n        if (typeof dataPoints[i].y !== \"number\") {\n          if (i > 0) {\n            // if first dataPoint is null then no need to call stroke method\n            ctx.stroke();\n\n            if (isCanvasSupported) {\n              ghostCtx.stroke();\n            }\n          }\n\n          prevDataNull = true;\n          continue;\n        }\n\n        x = plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5 << 0;\n        y = plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5 << 0;\n        var id = dataSeries.dataPointIds[i];\n        this._eventManager.objectMap[id] = {\n          id: id,\n          objectType: \"dataPoint\",\n          dataSeriesIndex: dataSeriesIndex,\n          dataPointIndex: i,\n          x1: x,\n          y1: y\n        }; //dataSeries.noDataPointsInPlotArea++;\n\n        if (isFirstDataPointInPlotArea || prevDataNull) {\n          ctx.beginPath();\n          ctx.moveTo(x, y);\n\n          if (isCanvasSupported) {\n            ghostCtx.beginPath();\n            ghostCtx.moveTo(x, y);\n          }\n\n          isFirstDataPointInPlotArea = false;\n          prevDataNull = false;\n        } else {\n          ctx.lineTo(x, y);\n          if (isCanvasSupported) ghostCtx.lineTo(x, y);\n\n          if (i % 500 == 0) {\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n\n            if (isCanvasSupported) {\n              ghostCtx.stroke();\n              ghostCtx.beginPath();\n              ghostCtx.moveTo(x, y);\n            }\n          }\n        } //Render Marker\n\n\n        if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {\n          var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);\n          markers.push(markerProps); //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {\n          //\tdataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);\n          //}\n\n          var markerColor = intToHexColorString(id); //window.console.log(\"index: \" + i + \"; id: \" + id + \"; hex: \" + markerColor);\n\n          if (isCanvasSupported) {\n            markers.push({\n              x: x,\n              y: y,\n              ctx: ghostCtx,\n              type: markerProps.type,\n              size: markerProps.size,\n              color: markerColor,\n              borderColor: markerColor,\n              borderThickness: markerProps.borderThickness\n            });\n          }\n        }\n\n        if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {\n          this._indexLabels.push({\n            chartType: \"line\",\n            dataPoint: dataPoints[i],\n            dataSeries: dataSeries,\n            point: {\n              x: x,\n              y: y\n            },\n            direction: dataPoints[i].y >= 0 ? 1 : -1,\n            color: color\n          });\n        }\n      }\n\n      ctx.stroke();\n      if (isCanvasSupported) ghostCtx.stroke();\n    }\n  }\n\n  RenderHelper.drawMarkers(markers);\n  ctx.restore();\n  ctx.beginPath();\n  if (isCanvasSupported) ghostCtx.beginPath(); //source and dest would be same when animation is not enabled\n\n  var animationInfo = {\n    source: ctx,\n    dest: this.plotArea.ctx,\n    animationCallback: AnimationHelper.xClipAnimation,\n    easingFunction: AnimationHelper.easing.linear,\n    animationBase: 0\n  };\n  return animationInfo;\n};\n\nChart.prototype.renderStepLine = function (plotUnit) {\n  var ctx = plotUnit.targetCanvasCtx || this.plotArea.ctx;\n  var totalDataSeries = plotUnit.dataSeriesIndexes.length;\n  if (totalDataSeries <= 0) return;\n  var ghostCtx = this._eventManager.ghostCtx; //var ghostCtx = this.overlaidCanvasCtx;\n\n  ctx.save();\n  var plotArea = this.plotArea;\n  ctx.beginPath();\n  ctx.rect(plotArea.x1, plotArea.y1, plotArea.width, plotArea.height);\n  ctx.clip();\n  var markers = [];\n\n  for (var j = 0; j < plotUnit.dataSeriesIndexes.length; j++) {\n    var dataSeriesIndex = plotUnit.dataSeriesIndexes[j];\n    var dataSeries = this.data[dataSeriesIndex];\n    ctx.lineWidth = dataSeries.lineThickness;\n    var dataPoints = dataSeries.dataPoints;\n\n    if (ctx.setLineDash) {\n      ctx.setLineDash(getLineDashArray(dataSeries.lineDashType, dataSeries.lineThickness));\n    }\n\n    var seriesId = dataSeries.id;\n    this._eventManager.objectMap[seriesId] = {\n      objectType: \"dataSeries\",\n      dataSeriesIndex: dataSeriesIndex\n    };\n    var hexColor = intToHexColorString(seriesId);\n    ghostCtx.strokeStyle = hexColor; //ghostCtx.lineWidth = dataSeries.lineThickness;\n\n    ghostCtx.lineWidth = dataSeries.lineThickness > 0 ? Math.max(dataSeries.lineThickness, 4) : 0;\n    var colorSet = dataSeries._colorSet;\n    var color = colorSet[0];\n    ctx.strokeStyle = color;\n    var isFirstDataPointInPlotArea = true;\n    var i = 0,\n        x,\n        y;\n    var dataPointX; //Used so that when dataPoint.x is a DateTime value, it doesn't get converted to number back and forth.\n    //if (!dataSeries._options.markerSize && dataSeries.dataPoints.length < 1000)\n    //    dataSeries.markerSize = 8;\n\n    ctx.beginPath();\n\n    if (dataPoints.length > 0) {\n      //var xy = this.getPixelCoordinatesOnPlotArea(dataPoints[0].x, dataPoints[0].y);\n      //dataSeries.noDataPointsInPlotArea = 0\n      var prevDataNull = false;\n\n      for (i = 0; i < dataPoints.length; i++) {\n        dataPointX = dataPoints[i].getTime ? dataPoints[i].x.getTime() : dataPoints[i].x;\n        if (dataPointX < plotUnit.axisX.dataInfo.viewPortMin || dataPointX > plotUnit.axisX.dataInfo.viewPortMax) continue; //if (!isFinite(dataPoints[i].y))\n        //    continue;\n\n        if (typeof dataPoints[i].y !== \"number\") {\n          if (i > 0) {\n            // if first dataPoint is null then no need to call stroke method\n            ctx.stroke();\n\n            if (isCanvasSupported) {\n              ghostCtx.stroke();\n            }\n          }\n\n          prevDataNull = true;\n          continue;\n        }\n\n        var prevY = y;\n        x = plotUnit.axisX.conversionParameters.reference + plotUnit.axisX.conversionParameters.pixelPerUnit * (dataPointX - plotUnit.axisX.conversionParameters.minimum) + .5 << 0;\n        y = plotUnit.axisY.conversionParameters.reference + plotUnit.axisY.conversionParameters.pixelPerUnit * (dataPoints[i].y - plotUnit.axisY.conversionParameters.minimum) + .5 << 0;\n        var id = dataSeries.dataPointIds[i];\n        this._eventManager.objectMap[id] = {\n          id: id,\n          objectType: \"dataPoint\",\n          dataSeriesIndex: dataSeriesIndex,\n          dataPointIndex: i,\n          x1: x,\n          y1: y\n        }; //dataSeries.noDataPointsInPlotArea++;\n\n        if (isFirstDataPointInPlotArea || prevDataNull) {\n          ctx.beginPath();\n          ctx.moveTo(x, y);\n\n          if (isCanvasSupported) {\n            ghostCtx.beginPath();\n            ghostCtx.moveTo(x, y);\n          }\n\n          isFirstDataPointInPlotArea = false;\n          prevDataNull = false;\n        } else {\n          ctx.lineTo(x, prevY);\n          if (isCanvasSupported) ghostCtx.lineTo(x, prevY);\n          ctx.lineTo(x, y);\n          if (isCanvasSupported) ghostCtx.lineTo(x, y);\n\n          if (i % 500 == 0) {\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n\n            if (isCanvasSupported) {\n              ghostCtx.stroke();\n              ghostCtx.beginPath();\n              ghostCtx.moveTo(x, y);\n            }\n          }\n        } //Render Marker\n\n\n        if (dataPoints[i].markerSize > 0 || dataSeries.markerSize > 0) {\n          var markerProps = dataSeries.getMarkerProperties(i, x, y, ctx);\n          markers.push(markerProps); //if (!dataSeries.maxWidthInX || markerProps.size > dataSeries.maxWidthInX) {\n          //\tdataSeries.maxWidthInX = markerProps.size / (plotUnit.axisX.conversionParameters.pixelPerUnit > 1 ? plotUnit.axisX.conversionParameters.pixelPerUnit - 1 : plotUnit.axisX.conversionParameters.pixelPerUnit);\n          //}\n\n          var markerColor = intToHexColorString(id); //window.console.log(\"index: \" + i + \"; id: \" + id + \"; hex: \" + markerColor);\n\n          if (isCanvasSupported) {\n            markers.push({\n              x: x,\n              y: y,\n              ctx: ghostCtx,\n              type: markerProps.type,\n              size: markerProps.size,\n              color: markerColor,\n              borderColor: markerColor,\n              borderThickness: markerProps.borderThickness\n            });\n          }\n        }\n\n        if (dataPoints[i].indexLabel || dataSeries.indexLabel || dataPoints[i].indexLabelFormatter || dataSeries.indexLabelFormatter) {\n          this._indexLabels.push({\n            chartType: \"stepLine\",\n            dataPoint: dataPoints[i],\n            dataSeries: dataSeries,\n            point: {\n              x: x,\n              y: y\n            },\n            direction: dataPoints[i].y >= 0 ? 1 : -1,\n            color: color\n          });\n        }\n      }\n\n      ctx.stroke();\n      if (isCanvasSupported) ghostCtx.stroke();\n    }\n  }\n\n  RenderHelper.drawMarkers(markers);\n  ctx.restore();\n  ctx.beginPath();\n  if (isCanvasSupported) ghostCtx.beginPath(); //source and dest would be same when animation is not enabled\n\n  var animationInfo = {\n    source: ctx,\n    dest: this.plotArea.ctx,\n    animationCallback: AnimationHelper.xClipAnimation,\n    easingFunction: AnimationHelper.easing.linear,\n    animationBase: 0\n  };\n  return animationInfo;\n};\n\nChart.prototype.animationRequestId = null;\n\nChart.prototype.requestAnimFrame = function () {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n}();\n\nChart.prototype.cancelRequestAnimFrame = function () {\n  return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;\n}();\n\nChart.prototype.getPercentAndTotal = function (ds, dp) {\n  var dpX = null;\n  var total = null;\n  var percent = null;\n\n  if (ds.type.indexOf(\"stacked\") >= 0) {\n    total = 0;\n    dpX = dp.x.getTime ? dp.x.getTime() : dp.x;\n\n    if (dpX in ds.plotUnit.yTotals) {\n      total = ds.plotUnit.yTotals[dpX];\n\n      if (!isNaN(dp.y)) {\n        if (total === 0) percent = 0;else percent = dp.y / total * 100;\n      } else percent = 0;\n    }\n  } else if (ds.type === \"pie\" || ds.type === \"doughnut\") {\n    total = 0;\n\n    for (var i = 0; i < ds.dataPoints.length; i++) {\n      if (!isNaN(ds.dataPoints[i].y)) total += ds.dataPoints[i].y;\n    }\n\n    if (!isNaN(dp.y)) percent = dp.y / total * 100;else percent = 0;\n  }\n\n  return {\n    percent: percent,\n    total: total\n  };\n};\n\nChart.prototype.replaceKeywordsWithValue = function (str, dp, ds, dpIndex, indexKeywordValue) {\n  //var regex = /\\{\\s*[a-zA-Z]+\\s*\\}|\"[^\"]*\"|'[^']*'/g;\n  var regex = /\\{.*?\\}|\"[^\"]*\"|'[^']*'/g;\n  var chart = this;\n  indexKeywordValue = typeof indexKeywordValue === \"undefined\" ? 0 : indexKeywordValue;\n\n  if ((ds.type.indexOf(\"stacked\") >= 0 || ds.type === \"pie\" || ds.type === \"doughnut\") && (str.indexOf(\"#percent\") >= 0 || str.indexOf(\"#total\") >= 0)) {\n    var percent = \"#percent\";\n    var total = \"#total\";\n    var dpX = null;\n    var percentAndTotal = this.getPercentAndTotal(ds, dp);\n    total = isNaN(percentAndTotal.total) ? total : percentAndTotal.total;\n    percent = isNaN(percentAndTotal.percent) ? percent : percentAndTotal.percent;\n\n    do {\n      var percentFormatString = \"\";\n      if (ds.percentFormatString) percentFormatString = ds.percentFormatString;else {\n        percentFormatString = \"#,##0.\";\n        var numberOfDecimals = Math.max(Math.ceil(Math.log(1 / Math.abs(percent)) / Math.LN10), 2);\n        if (isNaN(numberOfDecimals) || !isFinite(numberOfDecimals)) numberOfDecimals = 2;\n\n        for (var n = 0; n < numberOfDecimals; n++) {\n          percentFormatString += \"#\";\n        }\n      }\n      str = str.replace(\"#percent\", numberFormat(percent, percentFormatString, chart._cultureInfo));\n      str = str.replace(\"#total\", numberFormat(total, ds.yValueFormatString ? ds.yValueFormatString : \"#,##0.########\"));\n    } while (str.indexOf(\"#percent\") >= 0 || str.indexOf(\"#total\") >= 0);\n  }\n\n  var fcn = function ($0) {\n    if ($0[0] === \"\\\"\" && $0[$0.length - 1] === \"\\\"\" || $0[0] === \"\\'\" && $0[$0.length - 1] === \"\\'\") return $0.slice(1, $0.length - 1);\n    var key = trimString($0.slice(1, $0.length - 1));\n    key = key.replace(\"#index\", indexKeywordValue);\n    var index = null;\n\n    try {\n      var match = key.match(/(.*?)\\s*\\[\\s*(.*?)\\s*\\]/);\n\n      if (match && match.length > 0) {\n        index = trimString(match[2]);\n        key = trimString(match[1]);\n      }\n    } catch (e) {}\n\n    ;\n    var obj = null;\n\n    if (key === \"color\") {\n      return dp.color ? dp.color : ds.color ? ds.color : ds._colorSet[dpIndex % ds._colorSet.length];\n    }\n\n    if (dp.hasOwnProperty(key)) obj = dp;else if (ds.hasOwnProperty(key)) obj = ds;else return \"\";\n    var value = obj[key];\n    if (index !== null) value = value[index];\n\n    if (key === \"x\") {\n      if (chart.axisX && chart.plotInfo.axisXValueType === \"dateTime\") return dateFormat(value, dp.xValueFormatString ? dp.xValueFormatString : ds.xValueFormatString ? ds.xValueFormatString : chart.axisX && chart.axisX.valueFormatString ? chart.axisX.valueFormatString : \"DD MMM YY\", chart._cultureInfo);else return numberFormat(value, dp.xValueFormatString ? dp.xValueFormatString : ds.xValueFormatString ? ds.xValueFormatString : \"#,##0.########\", chart._cultureInfo);\n    } else if (key === \"y\") return numberFormat(value, dp.yValueFormatString ? dp.yValueFormatString : ds.yValueFormatString ? ds.yValueFormatString : \"#,##0.########\", chart._cultureInfo);else if (key === \"z\") return numberFormat(value, dp.zValueFormatString ? dp.zValueFormatString : ds.zValueFormatString ? ds.zValueFormatString : \"#,##0.########\", chart._cultureInfo);else return value;\n  };\n\n  return str.replace(regex, fcn);\n};\n\nChart.prototype.renderSpline = SplineChart;\nChart.prototype.renderColumn = ColumnChart;\nChart.prototype.renderStackedColumn = StackedColumnChart;\nChart.prototype.renderStackedColumn100 = StackedColumn100Chart;\nChart.prototype.renderBar = BarChart;\nChart.prototype.renderStackedBar = StackedBarChart;\nChart.prototype.renderStackedBar100 = StackedBar100Chart;\nChart.prototype.renderArea = AreaChart;\nChart.prototype.renderSplineArea = SplineAreaChart;\nChart.prototype.renderStepArea = StepAreaChart;\nChart.prototype.renderStackedArea = StackedAreaChart;\nChart.prototype.renderStackedArea100 = StackedArea100Chart;\nChart.prototype.renderBubble = BubbleChart;\nChart.prototype.renderScatter = ScatterChart;\nChart.prototype.renderCandlestick = CandlestickChart;\nChart.prototype.renderRangeColumn = RangeColumnChart;\nChart.prototype.renderRangeBar = RangeBarChart;\nChart.prototype.renderRangeArea = RangeAreaChart;\nChart.prototype.renderRangeSplineArea = RangeSplineAreaChart;\nChart.prototype.renderPie = PieChart;\nexport default Chart;","map":null,"metadata":{},"sourceType":"module"}