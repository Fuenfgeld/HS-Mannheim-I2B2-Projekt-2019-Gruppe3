{"ast":null,"code":"import CanvasJSObject from './canvasjs';\nimport { extend, getProperty } from '../helpers/utils';\n\nfunction DataSeries(chart, options, theme, index, id) {\n  DataSeries.base.constructor.call(this, \"DataSeries\", options, theme);\n  this.chart = chart;\n  this.canvas = chart.canvas;\n  this._ctx = chart.canvas.ctx;\n  this.index = index;\n  this.noDataPointsInPlotArea = 0; //this.maxWidthInX = 0;\n\n  this.id = id;\n  this.chart._eventManager.objectMap[id] = {\n    id: id,\n    objectType: \"dataSeries\",\n    dataSeriesIndex: index\n  };\n  this.dataPointIds = [];\n  this.plotUnit = [];\n  this.axisX = null;\n  this.axisY = null;\n\n  if (this.fillOpacity === null) {\n    if (this.type.match(/area/i)) this.fillOpacity = .7;else this.fillOpacity = 1;\n  }\n\n  this.axisPlacement = this.getDefaultAxisPlacement();\n\n  if (typeof this._options.indexLabelFontSize === \"undefined\") {\n    this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize);\n  }\n}\n\nextend(DataSeries, CanvasJSObject); //Static Method that returns the axisPlacement for a given ChartType. Returns one of \"normal\", \"xySwapped\", \"none\"\n\nDataSeries.prototype.getDefaultAxisPlacement = function () {\n  //if (!this.visible)\n  //\treturn \"none\";\n  //type = this.type.toLowerCase();\n  var type = this.type;\n\n  if (type === \"column\" || type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"area\" || type === \"stepArea\" || type === \"splineArea\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bubble\" || type === \"scatter\" || type === \"stackedArea\" || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stackedArea100\" || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\n    return \"normal\";\n  } else if (type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\" || type === \"rangeBar\") {\n    return \"xySwapped\";\n  } else if (type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\n    return \"none\";\n  } else {\n    window.console.log(\"Unknown Chart Type: \" + type);\n    return null;\n  }\n};\n\nDataSeries.getDefaultLegendMarker = function (type) {\n  //type = type.toLowerCase();\n  if (type === \"column\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\" || type === \"bubble\" || type === \"scatter\" || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stepArea\" || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeBar\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\n    return \"square\";\n  } else if (type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\n    return \"circle\";\n  } else if (type === \"area\" || type === \"splineArea\" || type === \"stackedArea\" || type === \"stackedArea100\") {\n    return \"triangle\";\n  } else {\n    window.console.log(\"Unknown Chart Type: \" + type);\n    return null;\n  }\n}; //Finds dataPoint with the given x value. If findClosest is set, finds dataPoint with closest x value.\n//Returns searchResult object if found, else returns null\n\n\nDataSeries.prototype.getDataPointAtX = function (x, findClosest) {\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\n  var searchResult = {\n    dataPoint: null,\n    distance: Infinity,\n    index: NaN\n  };\n  var dataPoint = null;\n  var j = 0;\n  var i = 0;\n  var direction = 1; // +1 for foward and -1 for backward.\n\n  var minimumXDistance = Infinity;\n  var forwardMissCount = 0,\n      backwardMissCount = 0;\n  var maxMissCount = 1000;\n  var searchStartIndex = 0;\n\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\n    //var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\n    //if (xRange > 0)\n    //\tsearchStartIndex = ((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0;\n    //else\n    //\tsearchStartIndex = 0;\n    var xRange = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x;\n    if (xRange > 0) searchStartIndex = Math.min(Math.max((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length);else searchStartIndex = 0; //searchStartIndex = ((this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) / this.dataPoints.length * (x - this.dataPoints[0].x)) >> 0;\n  }\n\n  while (true) {\n    i = direction > 0 ? searchStartIndex + j : searchStartIndex - j;\n\n    if (i >= 0 && i < this.dataPoints.length) {\n      dataPoint = this.dataPoints[i];\n      var distance = Math.abs(dataPoint.x - x);\n\n      if (distance < searchResult.distance) {\n        searchResult.dataPoint = dataPoint;\n        searchResult.distance = distance;\n        searchResult.index = i;\n      }\n\n      var xDistance = Math.abs(dataPoint.x - x);\n      if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n        if (direction > 0) forwardMissCount++;else backwardMissCount++;\n      }\n      if (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount) break;\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length) break;\n\n    if (direction === -1) {\n      j++;\n      direction = 1;\n    } else direction = -1;\n  }\n\n  if (!findClosest && searchResult.dataPoint.x === x) return searchResult;else if (findClosest && searchResult.dataPoint !== null) return searchResult;else return null;\n}; // x & y should be in pixels. Can be used only after rendering the chart.\n\n\nDataSeries.prototype.getDataPointAtXY = function (x, y, getClosest) {\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\n  getClosest = getClosest || false;\n  var results = [];\n  var j = 0,\n      i = 0;\n  var direction = 1; // +1 for foward and -1 for backward.\n\n  var foundDataPoint = false;\n  var minimumXDistance = Infinity;\n  var forwardMissCount = 0,\n      backwardMissCount = 0;\n  var maxMissCount = 1000;\n  var searchStartIndex = 0;\n\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\n    var xval = this.chart.axisX.getXValueAt({\n      x: x,\n      y: y\n    });\n    var xRange = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x;\n    if (xRange > 0) searchStartIndex = Math.min(Math.max((this.dataPoints.length - 1) / xRange * (xval - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length);else searchStartIndex = 0; //var xRange = (this.axisX._absoluteMaximum - this.axisX._absoluteMinimum);\n    //if (xRange > 0)\n    //\tsearchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.axisX._absoluteMinimum)) >> 0, 0), this.dataPoints.length);\n    //else\n    //\tsearchStartIndex = 0;\n  }\n\n  while (true) {\n    //i = searchStartIndex + (j * direction);\n    i = direction > 0 ? searchStartIndex + j : searchStartIndex - j;\n\n    if (i >= 0 && i < this.dataPoints.length) {\n      var id = this.dataPointIds[i];\n      var visualInfo = this.chart._eventManager.objectMap[id];\n      var dataPoint = this.dataPoints[i];\n      var distance = null;\n\n      if (visualInfo) {\n        switch (this.type) {\n          case \"column\":\n          case \"stackedColumn\":\n          case \"stackedColumn100\":\n          case \"bar\":\n          case \"stackedBar\":\n          case \"stackedBar100\":\n          case \"rangeColumn\":\n          case \"rangeBar\":\n            if (x >= visualInfo.x1 && x <= visualInfo.x2 && y >= visualInfo.y1 && y <= visualInfo.y2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y1 - y), Math.abs(visualInfo.y2 - y)) //distance:0\n\n              });\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"line\":\n          case \"stepLine\":\n          case \"spline\":\n          case \"area\":\n          case \"stepArea\":\n          case \"stackedArea\":\n          case \"stackedArea100\":\n          case \"splineArea\":\n          case \"scatter\":\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\n            var snapDistance = getClosest ? 20 : markerSize;\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\n\n            if (distance <= snapDistance) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n            }\n\n            var xDistance = Math.abs(visualInfo.x1 - x);\n            if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n              if (direction > 0) forwardMissCount++;else backwardMissCount++;\n            }\n\n            if (distance <= markerSize / 2) {\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"rangeArea\":\n          case \"rangeSplineArea\":\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\n            var snapDistance = getClosest ? 20 : markerSize;\n            distance = Math.min(Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2)), Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y2 - y, 2)));\n\n            if (distance <= snapDistance) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n            }\n\n            var xDistance = Math.abs(visualInfo.x1 - x);\n            if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n              if (direction > 0) forwardMissCount++;else backwardMissCount++;\n            }\n\n            if (distance <= markerSize / 2) {\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"bubble\":\n            var markerSize = visualInfo.size;\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\n\n            if (distance <= markerSize / 2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"pie\":\n          case \"doughnut\":\n            var center = visualInfo.center;\n            var innerRadius = this.type === \"doughnut\" ? visualInfo.percentInnerRadius * visualInfo.radius : 0;\n            distance = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2));\n\n            if (distance < visualInfo.radius && distance > innerRadius) {\n              var deltaY = y - center.y;\n              var deltaX = x - center.x;\n              var angle = Math.atan2(deltaY, deltaX);\n              if (angle < 0) angle += Math.PI * 2;\n              angle = Number(((angle / Math.PI * 180 % 360 + 360) % 360).toFixed(12)); //console.log(angle);\n\n              var startAngle = Number(((visualInfo.startAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12));\n              var endAngle = Number(((visualInfo.endAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12)); //So that data point is detected when there is only one dataPoint\n\n              if (endAngle === 0 && visualInfo.endAngle > 1) {\n                endAngle = 360;\n              }\n\n              if (startAngle >= endAngle && dataPoint.y !== 0) {\n                endAngle += 360;\n                if (angle < startAngle) angle += 360;\n              }\n\n              if (angle > startAngle && angle < endAngle) {\n                results.push({\n                  dataPoint: dataPoint,\n                  dataPointIndex: i,\n                  dataSeries: this,\n                  distance: 0\n                });\n                foundDataPoint = true;\n              }\n            }\n\n            break;\n\n          case \"candlestick\":\n            if (x >= visualInfo.x1 - visualInfo.borderThickness / 2 && x <= visualInfo.x2 + visualInfo.borderThickness / 2 && y >= visualInfo.y2 - visualInfo.borderThickness / 2 && y <= visualInfo.y3 + visualInfo.borderThickness / 2 || Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && y >= visualInfo.y1 && y <= visualInfo.y4) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y)) //distance:0\n\n              });\n              foundDataPoint = true;\n            }\n\n            break;\n\n          case \"ohlc\":\n            if (Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && y >= visualInfo.y2 && y <= visualInfo.y3 || x >= visualInfo.x1 && x <= (visualInfo.x2 + visualInfo.x1) / 2 && y >= visualInfo.y1 - visualInfo.borderThickness / 2 && y <= visualInfo.y1 + visualInfo.borderThickness / 2 || x >= (visualInfo.x1 + visualInfo.x2) / 2 && x <= visualInfo.x2 && y >= visualInfo.y4 - visualInfo.borderThickness / 2 && y <= visualInfo.y4 + visualInfo.borderThickness / 2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y)) //distance:0\n\n              });\n              foundDataPoint = true;\n            }\n\n            break;\n        }\n\n        if (foundDataPoint || forwardMissCount > maxMissCount && backwardMissCount > maxMissCount) break;\n      }\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length) break;\n\n    if (direction === -1) {\n      j++;\n      direction = 1;\n    } else direction = -1;\n  }\n\n  var closestResult = null;\n\n  for (var m = 0; m < results.length; m++) {\n    if (!closestResult) {\n      closestResult = results[m];\n    } else if (results[m].distance <= closestResult.distance) {\n      closestResult = results[m];\n    }\n  } //if (window.console)\n  //\twindow.console.log(\"forwardMissCount: \" + forwardMissCount + \"; backwardMissCount: \" + backwardMissCount + \"; getClosest: \" + getClosest);\n  //if (window.console && closestResult)\n  //    window.console.log(j + \": distance = \" + closestResult.distance);\n\n\n  return closestResult;\n};\n\nDataSeries.prototype.getMarkerProperties = function (index, x, y, ctx) {\n  var dataPoints = this.dataPoints;\n  var dataSeries = this;\n  var markerColor = dataPoints[index].markerColor ? dataPoints[index].markerColor : dataSeries.markerColor ? dataSeries.markerColor : dataPoints[index].color ? dataPoints[index].color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[index % dataSeries._colorSet.length];\n  var markerBorderColor = dataPoints[index].markerBorderColor ? dataPoints[index].markerBorderColor : dataSeries.markerBorderColor ? dataSeries.markerBorderColor : null;\n  var markerBorderThickness = dataPoints[index].markerBorderThickness ? dataPoints[index].markerBorderThickness : dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : null;\n  var markerType = dataPoints[index].markerType ? dataPoints[index].markerType : dataSeries.markerType;\n  var markerSize = dataPoints[index].markerSize ? dataPoints[index].markerSize : dataSeries.markerSize;\n  return {\n    x: x,\n    y: y,\n    ctx: ctx,\n    type: markerType,\n    size: markerSize,\n    color: markerColor,\n    borderColor: markerBorderColor,\n    borderThickness: markerBorderThickness\n  };\n};\n\nexport default DataSeries;","map":null,"metadata":{},"sourceType":"module"}