{"ast":null,"code":"import DataSeries from './data_series';\nimport CanvasJSObject from './canvasjs';\nimport TextBlock from './text_block';\nimport RenderHelper from '../helpers/render';\nimport { extend, getFontHeightInPixels } from '../helpers/utils';\n\nfunction Legend(chart, options, theme) {\n  Legend.base.constructor.call(this, \"Legend\", options, theme);\n  this.chart = chart;\n  this.canvas = chart.canvas;\n  this.ctx = this.chart.ctx;\n  this.ghostCtx = this.chart._eventManager.ghostCtx;\n  this.items = [];\n  this.width = 0, //this.fontSize = 12,\n  this.height = 0, this.orientation = null, this.dataSeries = [];\n  this.bounds = {\n    x1: null,\n    y1: null,\n    x2: null,\n    y2: null\n  };\n\n  if (typeof this._options.fontSize === \"undefined\") {\n    this.fontSize = this.chart.getAutoFontSize(this.fontSize); //window.console.log(\"fontSize: \" + this.fontSize);\n  }\n\n  this.lineHeight = getFontHeightInPixels(this.fontFamily, this.fontSize, this.fontWeight);\n  this.horizontalSpacing = this.fontSize;\n}\n\nextend(Legend, CanvasJSObject);\n\nLegend.prototype.render = function () {\n  var container = !this.dockInsidePlotArea ? this.chart : this.chart.plotArea;\n  var freeSpace = container.layoutManager.getFreeSpace();\n  var position = null;\n  var top = 0;\n  var left = 0;\n  var maxWidth = 0;\n  var maxHeight = 0;\n  var itemMargin = 5;\n  var items = [];\n  var rows = []; //this.ctx.font = getFontString(\"\", this, null);\n  //this.ctx.fontColor = this.fontColor;\n\n  if (this.verticalAlign === \"top\" || this.verticalAlign === \"bottom\") {\n    this.orientation = \"horizontal\";\n    position = this.verticalAlign;\n    maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width * .7;\n    maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height * .5;\n  } else if (this.verticalAlign === \"center\") {\n    this.orientation = \"vertical\";\n    position = this.horizontalAlign;\n    maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width * .5;\n    maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height * .7;\n  }\n\n  for (var i = 0; i < this.dataSeries.length; i++) {\n    var dataSeries = this.dataSeries[i];\n\n    if (dataSeries.type !== \"pie\" && dataSeries.type !== \"doughnut\" && dataSeries.type !== \"funnel\") {\n      var markerType = dataSeries.legendMarkerType ? dataSeries.legendMarkerType : (dataSeries.type === \"line\" || dataSeries.type === \"stepLine\" || dataSeries.type === \"spline\" || dataSeries.type === \"scatter\" || dataSeries.type === \"bubble\") && dataSeries.markerType ? dataSeries.markerType : DataSeries.getDefaultLegendMarker(dataSeries.type);\n      var legendText = dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({\n        chart: this.chart,\n        legend: this._options,\n        dataSeries: dataSeries,\n        dataPoint: null\n      }) : dataSeries.name;\n      var markerColor = dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataSeries.markerColor ? dataSeries.markerColor : dataSeries._colorSet[0];\n      var markerSize = !dataSeries.markerSize && (dataSeries.type === \"line\" || dataSeries.type === \"stepLine\" || dataSeries.type === \"spline\") ? 0 : this.lineHeight * .6;\n      var markerBorderColor = dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataSeries.markerBorderColor;\n      var markerBorderThickness = dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;\n      var lineColor = dataSeries._colorSet[0];\n      legendText = this.chart.replaceKeywordsWithValue(legendText, dataSeries.dataPoints[0], dataSeries, i);\n      var item = {\n        markerType: markerType,\n        markerColor: markerColor,\n        text: legendText,\n        textBlock: null,\n        chartType: dataSeries.type,\n        markerSize: markerSize,\n        lineColor: dataSeries._colorSet[0],\n        dataSeriesIndex: dataSeries.index,\n        dataPointIndex: null,\n        markerBorderColor: markerBorderColor,\n        markerBorderThickness: markerBorderThickness\n      };\n      items.push(item);\n    } else {\n      for (var dataPointIndex = 0; dataPointIndex < dataSeries.dataPoints.length; dataPointIndex++) {\n        var dataPoint = dataSeries.dataPoints[dataPointIndex];\n        var markerType = dataPoint.legendMarkerType ? dataPoint.legendMarkerType : dataSeries.legendMarkerType ? dataSeries.legendMarkerType : DataSeries.getDefaultLegendMarker(dataSeries.type);\n        var legendText = dataPoint.legendText ? dataPoint.legendText : dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({\n          chart: this.chart,\n          legend: this._options,\n          dataSeries: dataSeries,\n          dataPoint: dataPoint\n        }) : dataPoint.name ? dataPoint.name : \"DataPoint: \" + (dataPointIndex + 1);\n        var markerColor = dataPoint.legendMarkerColor ? dataPoint.legendMarkerColor : dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataPoint.color ? dataPoint.color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[dataPointIndex % dataSeries._colorSet.length];\n        var markerSize = this.lineHeight * .6;\n        var markerBorderColor = dataPoint.legendMarkerBorderColor ? dataPoint.legendMarkerBorderColor : dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataPoint.markerBorderColor ? dataPoint.markerBorderColor : dataSeries.markerBorderColor;\n        var markerBorderThickness = dataPoint.legendMarkerBorderThickness ? dataPoint.legendMarkerBorderThickness : dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataPoint.markerBorderThickness || dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;\n        legendText = this.chart.replaceKeywordsWithValue(legendText, dataPoint, dataSeries, dataPointIndex);\n        var item = {\n          markerType: markerType,\n          markerColor: markerColor,\n          text: legendText,\n          textBlock: null,\n          chartType: dataSeries.type,\n          markerSize: markerSize,\n          dataSeriesIndex: i,\n          dataPointIndex: dataPointIndex,\n          markerBorderColor: markerBorderColor,\n          markerBorderThickness: markerBorderThickness\n        };\n\n        if (dataPoint.showInLegend || dataSeries.showInLegend && dataPoint.showInLegend !== false) {\n          items.push(item);\n        }\n      }\n    }\n\n    item = null;\n  }\n\n  if (this.reversed === true) {\n    items.reverse();\n  } // Find out the required width and height of Legend and position the items relative to the container\n\n\n  if (items.length > 0) {\n    var row = null;\n    var rowIndex = 0; // required for vertical orientation\n\n    var textMaxWidth = 0;\n    var columnHeight = 0;\n\n    if (this.itemWidth !== null) {\n      if (this.itemMaxWidth !== null) {\n        textMaxWidth = Math.min(this.itemWidth, this.itemMaxWidth, maxWidth);\n      } else {\n        textMaxWidth = Math.min(this.itemWidth, maxWidth);\n      }\n    } else {\n      if (this.itemMaxWidth !== null) {\n        textMaxWidth = Math.min(this.itemMaxWidth, maxWidth);\n      } else {\n        textMaxWidth = maxWidth;\n      }\n    }\n\n    markerSize = markerSize === 0 ? this.lineHeight * .6 : markerSize;\n    textMaxWidth = textMaxWidth - (markerSize + this.horizontalSpacing * .1);\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\") {\n        textMaxWidth = textMaxWidth - 2 * (this.lineHeight * .1);\n      }\n\n      if (maxHeight <= 0 || typeof maxHeight === \"undefined\" || textMaxWidth <= 0 || typeof textMaxWidth === \"undefined\") {\n        continue;\n      }\n\n      if (this.orientation === \"horizontal\") {\n        item.textBlock = new TextBlock(this.ctx, {\n          x: 0,\n          y: 0,\n          //TBI\n          maxWidth: textMaxWidth,\n          maxHeight: this.itemWrap ? maxHeight : this.lineHeight,\n          //TBI: FontSize\n          angle: 0,\n          text: item.text,\n          horizontalAlign: \"left\",\n          //left, center, right\n          fontSize: this.fontSize,\n          //in pixels\n          fontFamily: this.fontFamily,\n          fontWeight: this.fontWeight,\n          //normal, bold, bolder, lighter,\n          fontColor: this.fontColor,\n          fontStyle: this.fontStyle,\n          // normal, italic, oblique\n          textBaseline: \"top\"\n        });\n        item.textBlock.measureText();\n\n        if (this.itemWidth !== null) {\n          item.textBlock.width = this.itemWidth - (markerSize + this.horizontalSpacing * .1 + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0));\n        }\n\n        if (!row || row.width + Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : this.horizontalSpacing) + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0)) > maxWidth) {\n          row = {\n            items: [],\n            width: 0\n          };\n          rows.push(row);\n          this.height += columnHeight;\n          columnHeight = 0;\n        }\n\n        columnHeight = Math.max(columnHeight, item.textBlock.height);\n        item.textBlock.x = row.width;\n        item.textBlock.y = 0;\n        row.width += Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : this.horizontalSpacing) + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0));\n        row.items.push(item);\n        this.width = Math.max(row.width, this.width);\n      } else {\n        item.textBlock = new TextBlock(this.ctx, {\n          x: 0,\n          y: 0,\n          //TBI\n          maxWidth: textMaxWidth,\n          maxHeight: this.itemWrap === true ? maxHeight : this.fontSize * 1.5,\n          //TBI: FontSize\n          angle: 0,\n          text: item.text,\n          horizontalAlign: \"left\",\n          //left, center, right\n          fontSize: this.fontSize,\n          //in pixels\n          fontFamily: this.fontFamily,\n          fontWeight: this.fontWeight,\n          //normal, bold, bolder, lighter,\n          fontColor: this.fontColor,\n          fontStyle: this.fontStyle,\n          // normal, italic, oblique\n          textBaseline: \"top\"\n        });\n        item.textBlock.measureText();\n\n        if (this.itemWidth !== null) {\n          item.textBlock.width = this.itemWidth - (markerSize + this.horizontalSpacing * .1 + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0));\n        }\n\n        if (this.height <= maxHeight) {\n          row = {\n            items: [],\n            width: 0\n          };\n          rows.push(row);\n        } else {\n          row = rows[rowIndex];\n          rowIndex = (rowIndex + 1) % rows.length;\n        }\n\n        this.height += item.textBlock.height;\n        item.textBlock.x = row.width; // relative to the row\n\n        item.textBlock.y = 0; // relative to the row\n\n        row.width += Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : this.horizontalSpacing) + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0));\n        row.items.push(item);\n        this.width = Math.max(row.width, this.width);\n      }\n    }\n\n    if (this.itemWrap === false) {\n      this.height = rows.length * this.lineHeight;\n    } else {\n      this.height += columnHeight;\n    }\n\n    this.height = Math.min(maxHeight, this.height);\n    this.width = Math.min(maxWidth, this.width);\n  }\n\n  if (this.verticalAlign === \"top\") {\n    if (this.horizontalAlign === \"left\") left = freeSpace.x1;else if (this.horizontalAlign === \"right\") left = freeSpace.x2 - this.width;else left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\n    top = freeSpace.y1;\n  } else if (this.verticalAlign === \"center\") {\n    if (this.horizontalAlign === \"left\") left = freeSpace.x1;else if (this.horizontalAlign === \"right\") left = freeSpace.x2 - this.width;else left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\n    top = freeSpace.y1 + freeSpace.height / 2 - this.height / 2;\n  } else if (this.verticalAlign === \"bottom\") {\n    if (this.horizontalAlign === \"left\") left = freeSpace.x1;else if (this.horizontalAlign === \"right\") left = freeSpace.x2 - this.width;else left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\n    top = freeSpace.y2 - this.height;\n  }\n\n  this.items = items; //Assign ids to all legendItems\n\n  for (var i = 0; i < this.items.length; i++) {\n    var item = items[i];\n    item.id = ++this.chart._eventManager.lastObjectId;\n    this.chart._eventManager.objectMap[item.id] = {\n      id: item.id,\n      objectType: \"legendItem\",\n      legendItemIndex: i,\n      dataSeriesIndex: item.dataSeriesIndex,\n      dataPointIndex: item.dataPointIndex\n    }; //delete item.textBlock;// Not Required anymore\n  }\n\n  var rowHeight = 0;\n\n  for (var i = 0; i < rows.length; i++) {\n    var row = rows[i];\n    var columnHeight = 0;\n\n    for (var itemIndex = 0; itemIndex < row.items.length; itemIndex++) {\n      var item = row.items[itemIndex];\n      var itemX = item.textBlock.x + left + (itemIndex === 0 ? markerSize * .2 : this.horizontalSpacing);\n      var itemY = top + rowHeight;\n      var ghostX = itemX;\n      if (!this.chart.data[item.dataSeriesIndex].visible) this.ctx.globalAlpha = .5;\n      this.ctx.save();\n      this.ctx.rect(left, top, maxWidth, maxHeight);\n      this.ctx.clip();\n\n      if (item.chartType === \"line\" || item.chartType === \"stepLine\" || item.chartType === \"spline\") {\n        this.ctx.strokeStyle = item.lineColor;\n        this.ctx.lineWidth = Math.ceil(this.lineHeight / 8);\n        this.ctx.beginPath();\n        this.ctx.moveTo(itemX - this.lineHeight * .1, itemY + this.lineHeight / 2);\n        this.ctx.lineTo(itemX + this.lineHeight * .7, itemY + this.lineHeight / 2);\n        this.ctx.stroke();\n        ghostX -= this.lineHeight * .1;\n      }\n\n      RenderHelper.drawMarker(itemX + markerSize / 2, itemY + this.lineHeight / 2, this.ctx, item.markerType, item.markerSize, item.markerColor, item.markerBorderColor, item.markerBorderThickness);\n      item.textBlock.x = itemX + this.horizontalSpacing * .1 + markerSize;\n\n      if (item.chartType === \"line\" || item.chartType === \"stepLine\" || item.chartType === \"spline\") {\n        item.textBlock.x = item.textBlock.x + this.lineHeight * .1;\n      }\n\n      item.textBlock.y = itemY;\n      item.textBlock.render(true);\n      this.ctx.restore();\n\n      if (itemIndex > 0) {\n        columnHeight = Math.max(columnHeight, item.textBlock.height);\n      } else {\n        columnHeight = item.textBlock.height;\n      }\n\n      if (!this.chart.data[item.dataSeriesIndex].visible) this.ctx.globalAlpha = 1;\n      var hexColor = intToHexColorString(item.id);\n      this.ghostCtx.fillStyle = hexColor;\n      this.ghostCtx.beginPath();\n      this.ghostCtx.fillRect(ghostX, item.textBlock.y, item.textBlock.x + item.textBlock.width - ghostX, item.textBlock.height);\n      item.x1 = this.chart._eventManager.objectMap[item.id].x1 = ghostX;\n      item.y1 = this.chart._eventManager.objectMap[item.id].y1 = item.textBlock.y;\n      item.x2 = this.chart._eventManager.objectMap[item.id].x2 = item.textBlock.x + item.textBlock.width;\n      item.y2 = this.chart._eventManager.objectMap[item.id].y2 = item.textBlock.y + item.textBlock.height;\n    }\n\n    rowHeight = rowHeight + columnHeight;\n  } //this.ctx.beginPath();\n  //this.ctx.lineWidth = 2;\n  //this.ctx.strokeStyle = \"red\";\n  //this.ctx.rect(left, top, this.width, this.height);\n  //this.ctx.stroke();\n\n\n  container.layoutManager.registerSpace(position, {\n    width: this.width + 2 + 2,\n    height: this.height + 5 + 5\n  });\n  this.bounds = {\n    x1: left,\n    y1: top,\n    x2: left + this.width,\n    y2: top + this.height\n  };\n};\n\nexport default Legend;","map":null,"metadata":{},"sourceType":"module"}